/* soapC.cpp
   Generated by gSOAP 2.7.13 from clipservice.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.13 2014-05-12 02:22:34 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__ProgramBasicEntityType:
		return soap_in_ns1__ProgramBasicEntityType(soap, NULL, NULL, "ns1:ProgramBasicEntityType");
	case SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType:
		return soap_in_CLIPSVR__ArrayOfProgramBasicEntityType(soap, NULL, NULL, "CLIPSVR:ArrayOfProgramBasicEntityType");
	case SOAP_TYPE_CLIPSVR__StatusDesc:
		return soap_in_CLIPSVR__StatusDesc(soap, NULL, NULL, "CLIPSVR:StatusDesc");
	case SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute:
		return soap_in_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, NULL, NULL, "CLIPSVR:ArrayOfExtentionAttributeTypeExtentionAttribute");
	case SOAP_TYPE_CLIPSVR__BreakPoint:
		return soap_in_CLIPSVR__BreakPoint(soap, NULL, NULL, "CLIPSVR:BreakPoint");
	case SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint:
		return soap_in_CLIPSVR__ArrayOfBreakPoint(soap, NULL, NULL, "CLIPSVR:ArrayOfBreakPoint");
	case SOAP_TYPE_CLIPSVR__OutMessageFile:
		return soap_in_CLIPSVR__OutMessageFile(soap, NULL, NULL, "CLIPSVR:OutMessageFile");
	case SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile:
		return soap_in_CLIPSVR__ArrayOfOutMessageFile(soap, NULL, NULL, "CLIPSVR:ArrayOfOutMessageFile");
	case SOAP_TYPE_CLIPSVR__OutMessage:
		return soap_in_CLIPSVR__OutMessage(soap, NULL, NULL, "CLIPSVR:OutMessage");
	case SOAP_TYPE_PointerTo_CLIPSVR__QueryCacheResponse:
		return soap_in_PointerTo_CLIPSVR__QueryCacheResponse(soap, NULL, NULL, "CLIPSVR:QueryCacheResponse");
	case SOAP_TYPE_PointerTo_CLIPSVR__QueryCache:
		return soap_in_PointerTo_CLIPSVR__QueryCache(soap, NULL, NULL, "CLIPSVR:QueryCache");
	case SOAP_TYPE_PointerTo_CLIPSVR__ClipIsExistQueryResponse:
		return soap_in_PointerTo_CLIPSVR__ClipIsExistQueryResponse(soap, NULL, NULL, "CLIPSVR:ClipIsExistQueryResponse");
	case SOAP_TYPE_PointerTo_CLIPSVR__ClipIsExistQuery:
		return soap_in_PointerTo_CLIPSVR__ClipIsExistQuery(soap, NULL, NULL, "CLIPSVR:ClipIsExistQuery");
	case SOAP_TYPE_PointerTo_CLIPSVR__MaterialQueryResponse:
		return soap_in_PointerTo_CLIPSVR__MaterialQueryResponse(soap, NULL, NULL, "CLIPSVR:MaterialQueryResponse");
	case SOAP_TYPE_PointerTo_CLIPSVR__MaterialQuery:
		return soap_in_PointerTo_CLIPSVR__MaterialQuery(soap, NULL, NULL, "CLIPSVR:MaterialQuery");
	case SOAP_TYPE_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse:
		return soap_in_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, NULL, NULL, "CLIPSVR:TransferTaskExcuteResultNotifyResponse");
	case SOAP_TYPE_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify:
		return soap_in_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(soap, NULL, NULL, "CLIPSVR:TransferTaskExcuteResultNotify");
	case SOAP_TYPE_PointerTo_CLIPSVR__OutStorageFunctionResponse:
		return soap_in_PointerTo_CLIPSVR__OutStorageFunctionResponse(soap, NULL, NULL, "CLIPSVR:OutStorageFunctionResponse");
	case SOAP_TYPE_PointerTo_CLIPSVR__OutStorageFunction:
		return soap_in_PointerTo_CLIPSVR__OutStorageFunction(soap, NULL, NULL, "CLIPSVR:OutStorageFunction");
	case SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult:
		return soap_in_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult(soap, NULL, NULL, "ns1:ClipIsExistQueryResult-ClipArrayResult");
	case SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem:
		return soap_in_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, NULL, NULL, "ns1:ClipIsExistQueryResult-ClipArrayResult-ClipItem");
	case SOAP_TYPE_PointerTo_ns1__ClipExistQueryRequest_ClipArray:
		return soap_in_PointerTo_ns1__ClipExistQueryRequest_ClipArray(soap, NULL, NULL, "ns1:ClipExistQueryRequest-ClipArray");
	case SOAP_TYPE_PointerTo_ns1__MaterialQueryRequest_PlanAirDate:
		return soap_in_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(soap, NULL, NULL, "ns1:MaterialQueryRequest-PlanAirDate");
	case SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult:
		return soap_in_PointerTo_ns1__ClipIsExistQueryResult(soap, NULL, NULL, "ns1:ClipIsExistQueryResult");
	case SOAP_TYPE_PointerTo_ns1__ClipExistQueryRequest:
		return soap_in_PointerTo_ns1__ClipExistQueryRequest(soap, NULL, NULL, "ns1:ClipExistQueryRequest");
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfProgramBasicEntityType:
		return soap_in_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(soap, NULL, NULL, "CLIPSVR:ArrayOfProgramBasicEntityType");
	case SOAP_TYPE_PointerTo_ns1__MaterialQueryRequest:
		return soap_in_PointerTo_ns1__MaterialQueryRequest(soap, NULL, NULL, "ns1:MaterialQueryRequest");
	case SOAP_TYPE_PointerToCLIPSVR__StatusDesc:
		return soap_in_PointerToCLIPSVR__StatusDesc(soap, NULL, NULL, "CLIPSVR:StatusDesc");
	case SOAP_TYPE_PointerToCLIPSVR__OutMessage:
		return soap_in_PointerToCLIPSVR__OutMessage(soap, NULL, NULL, "CLIPSVR:OutMessage");
	case SOAP_TYPE_PointerTons1__ProgramBasicEntityType:
		return soap_in_PointerTons1__ProgramBasicEntityType(soap, NULL, NULL, "ns1:ProgramBasicEntityType");
	case SOAP_TYPE_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute:
		return soap_in_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, NULL, NULL, "CLIPSVR:ArrayOfExtentionAttributeTypeExtentionAttribute-ExtentionAttribute");
	case SOAP_TYPE_PointerToCLIPSVR__BreakPoint:
		return soap_in_PointerToCLIPSVR__BreakPoint(soap, NULL, NULL, "CLIPSVR:BreakPoint");
	case SOAP_TYPE_PointerToCLIPSVR__OutMessageFile:
		return soap_in_PointerToCLIPSVR__OutMessageFile(soap, NULL, NULL, "CLIPSVR:OutMessageFile");
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute:
		return soap_in_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, NULL, NULL, "CLIPSVR:ArrayOfExtentionAttributeTypeExtentionAttribute");
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfBreakPoint:
		return soap_in_PointerToCLIPSVR__ArrayOfBreakPoint(soap, NULL, NULL, "CLIPSVR:ArrayOfBreakPoint");
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfOutMessageFile:
		return soap_in_PointerToCLIPSVR__ArrayOfOutMessageFile(soap, NULL, NULL, "CLIPSVR:ArrayOfOutMessageFile");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProgramBasicEntityType"))
		{	*type = SOAP_TYPE_ns1__ProgramBasicEntityType;
			return soap_in_ns1__ProgramBasicEntityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:ArrayOfProgramBasicEntityType"))
		{	*type = SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType;
			return soap_in_CLIPSVR__ArrayOfProgramBasicEntityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:StatusDesc"))
		{	*type = SOAP_TYPE_CLIPSVR__StatusDesc;
			return soap_in_CLIPSVR__StatusDesc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:ArrayOfExtentionAttributeTypeExtentionAttribute"))
		{	*type = SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute;
			return soap_in_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:BreakPoint"))
		{	*type = SOAP_TYPE_CLIPSVR__BreakPoint;
			return soap_in_CLIPSVR__BreakPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:ArrayOfBreakPoint"))
		{	*type = SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint;
			return soap_in_CLIPSVR__ArrayOfBreakPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:OutMessageFile"))
		{	*type = SOAP_TYPE_CLIPSVR__OutMessageFile;
			return soap_in_CLIPSVR__OutMessageFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:ArrayOfOutMessageFile"))
		{	*type = SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile;
			return soap_in_CLIPSVR__ArrayOfOutMessageFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:OutMessage"))
		{	*type = SOAP_TYPE_CLIPSVR__OutMessage;
			return soap_in_CLIPSVR__OutMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:ClipIsExistQueryResult-ClipArrayResult-ClipItem"))
		{	*type = SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem;
			return soap_in__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClipIsExistQueryResult-ClipArrayResult"))
		{	*type = SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult;
			return soap_in__ns1__ClipIsExistQueryResult_ClipArrayResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClipExistQueryRequest-ClipArray"))
		{	*type = SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray;
			return soap_in__ns1__ClipExistQueryRequest_ClipArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MaterialQueryRequest-PlanAirDate"))
		{	*type = SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate;
			return soap_in__ns1__MaterialQueryRequest_PlanAirDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:ArrayOfExtentionAttributeTypeExtentionAttribute-ExtentionAttribute"))
		{	*type = SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute;
			return soap_in__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClipIsExistQueryResult"))
		{	*type = SOAP_TYPE__ns1__ClipIsExistQueryResult;
			return soap_in__ns1__ClipIsExistQueryResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClipExistQueryRequest"))
		{	*type = SOAP_TYPE__ns1__ClipExistQueryRequest;
			return soap_in__ns1__ClipExistQueryRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MaterialQueryRequest"))
		{	*type = SOAP_TYPE__ns1__MaterialQueryRequest;
			return soap_in__ns1__MaterialQueryRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:QueryCacheResponse"))
		{	*type = SOAP_TYPE__CLIPSVR__QueryCacheResponse;
			return soap_in__CLIPSVR__QueryCacheResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:QueryCache"))
		{	*type = SOAP_TYPE__CLIPSVR__QueryCache;
			return soap_in__CLIPSVR__QueryCache(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:ClipIsExistQueryResponse"))
		{	*type = SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse;
			return soap_in__CLIPSVR__ClipIsExistQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:ClipIsExistQuery"))
		{	*type = SOAP_TYPE__CLIPSVR__ClipIsExistQuery;
			return soap_in__CLIPSVR__ClipIsExistQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:MaterialQueryResponse"))
		{	*type = SOAP_TYPE__CLIPSVR__MaterialQueryResponse;
			return soap_in__CLIPSVR__MaterialQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:MaterialQuery"))
		{	*type = SOAP_TYPE__CLIPSVR__MaterialQuery;
			return soap_in__CLIPSVR__MaterialQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:TransferTaskExcuteResultNotifyResponse"))
		{	*type = SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse;
			return soap_in__CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:TransferTaskExcuteResultNotify"))
		{	*type = SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify;
			return soap_in__CLIPSVR__TransferTaskExcuteResultNotify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:OutStorageFunctionResponse"))
		{	*type = SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse;
			return soap_in__CLIPSVR__OutStorageFunctionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "CLIPSVR:OutStorageFunction"))
		{	*type = SOAP_TYPE__CLIPSVR__OutStorageFunction;
			return soap_in__CLIPSVR__OutStorageFunction(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem:
		return ((_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *)ptr)->soap_out(soap, "ns1:ClipIsExistQueryResult-ClipArrayResult-ClipItem", id, NULL);
	case SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult:
		return ((_ns1__ClipIsExistQueryResult_ClipArrayResult *)ptr)->soap_out(soap, "ns1:ClipIsExistQueryResult-ClipArrayResult", id, NULL);
	case SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray:
		return ((_ns1__ClipExistQueryRequest_ClipArray *)ptr)->soap_out(soap, "ns1:ClipExistQueryRequest-ClipArray", id, NULL);
	case SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate:
		return ((_ns1__MaterialQueryRequest_PlanAirDate *)ptr)->soap_out(soap, "ns1:MaterialQueryRequest-PlanAirDate", id, NULL);
	case SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute:
		return ((_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *)ptr)->soap_out(soap, "CLIPSVR:ArrayOfExtentionAttributeTypeExtentionAttribute-ExtentionAttribute", id, NULL);
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__ns1__ClipIsExistQueryResult:
		return ((_ns1__ClipIsExistQueryResult *)ptr)->soap_out(soap, "ns1:ClipIsExistQueryResult", id, NULL);
	case SOAP_TYPE__ns1__ClipExistQueryRequest:
		return ((_ns1__ClipExistQueryRequest *)ptr)->soap_out(soap, "ns1:ClipExistQueryRequest", id, NULL);
	case SOAP_TYPE__ns1__MaterialQueryRequest:
		return ((_ns1__MaterialQueryRequest *)ptr)->soap_out(soap, "ns1:MaterialQueryRequest", id, NULL);
	case SOAP_TYPE_ns1__ProgramBasicEntityType:
		return ((ns1__ProgramBasicEntityType *)ptr)->soap_out(soap, tag, id, "ns1:ProgramBasicEntityType");
	case SOAP_TYPE__CLIPSVR__QueryCacheResponse:
		return ((_CLIPSVR__QueryCacheResponse *)ptr)->soap_out(soap, "CLIPSVR:QueryCacheResponse", id, NULL);
	case SOAP_TYPE__CLIPSVR__QueryCache:
		return ((_CLIPSVR__QueryCache *)ptr)->soap_out(soap, "CLIPSVR:QueryCache", id, NULL);
	case SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse:
		return ((_CLIPSVR__ClipIsExistQueryResponse *)ptr)->soap_out(soap, "CLIPSVR:ClipIsExistQueryResponse", id, NULL);
	case SOAP_TYPE__CLIPSVR__ClipIsExistQuery:
		return ((_CLIPSVR__ClipIsExistQuery *)ptr)->soap_out(soap, "CLIPSVR:ClipIsExistQuery", id, NULL);
	case SOAP_TYPE__CLIPSVR__MaterialQueryResponse:
		return ((_CLIPSVR__MaterialQueryResponse *)ptr)->soap_out(soap, "CLIPSVR:MaterialQueryResponse", id, NULL);
	case SOAP_TYPE__CLIPSVR__MaterialQuery:
		return ((_CLIPSVR__MaterialQuery *)ptr)->soap_out(soap, "CLIPSVR:MaterialQuery", id, NULL);
	case SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse:
		return ((_CLIPSVR__TransferTaskExcuteResultNotifyResponse *)ptr)->soap_out(soap, "CLIPSVR:TransferTaskExcuteResultNotifyResponse", id, NULL);
	case SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify:
		return ((_CLIPSVR__TransferTaskExcuteResultNotify *)ptr)->soap_out(soap, "CLIPSVR:TransferTaskExcuteResultNotify", id, NULL);
	case SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse:
		return ((_CLIPSVR__OutStorageFunctionResponse *)ptr)->soap_out(soap, "CLIPSVR:OutStorageFunctionResponse", id, NULL);
	case SOAP_TYPE__CLIPSVR__OutStorageFunction:
		return ((_CLIPSVR__OutStorageFunction *)ptr)->soap_out(soap, "CLIPSVR:OutStorageFunction", id, NULL);
	case SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType:
		return ((CLIPSVR__ArrayOfProgramBasicEntityType *)ptr)->soap_out(soap, tag, id, "CLIPSVR:ArrayOfProgramBasicEntityType");
	case SOAP_TYPE_CLIPSVR__StatusDesc:
		return ((CLIPSVR__StatusDesc *)ptr)->soap_out(soap, tag, id, "CLIPSVR:StatusDesc");
	case SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute:
		return ((CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *)ptr)->soap_out(soap, tag, id, "CLIPSVR:ArrayOfExtentionAttributeTypeExtentionAttribute");
	case SOAP_TYPE_CLIPSVR__BreakPoint:
		return ((CLIPSVR__BreakPoint *)ptr)->soap_out(soap, tag, id, "CLIPSVR:BreakPoint");
	case SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint:
		return ((CLIPSVR__ArrayOfBreakPoint *)ptr)->soap_out(soap, tag, id, "CLIPSVR:ArrayOfBreakPoint");
	case SOAP_TYPE_CLIPSVR__OutMessageFile:
		return ((CLIPSVR__OutMessageFile *)ptr)->soap_out(soap, tag, id, "CLIPSVR:OutMessageFile");
	case SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile:
		return ((CLIPSVR__ArrayOfOutMessageFile *)ptr)->soap_out(soap, tag, id, "CLIPSVR:ArrayOfOutMessageFile");
	case SOAP_TYPE_CLIPSVR__OutMessage:
		return ((CLIPSVR__OutMessage *)ptr)->soap_out(soap, tag, id, "CLIPSVR:OutMessage");
	case SOAP_TYPE_PointerTo_CLIPSVR__QueryCacheResponse:
		return soap_out_PointerTo_CLIPSVR__QueryCacheResponse(soap, tag, id, (_CLIPSVR__QueryCacheResponse *const*)ptr, "CLIPSVR:QueryCacheResponse");
	case SOAP_TYPE_PointerTo_CLIPSVR__QueryCache:
		return soap_out_PointerTo_CLIPSVR__QueryCache(soap, tag, id, (_CLIPSVR__QueryCache *const*)ptr, "CLIPSVR:QueryCache");
	case SOAP_TYPE_PointerTo_CLIPSVR__ClipIsExistQueryResponse:
		return soap_out_PointerTo_CLIPSVR__ClipIsExistQueryResponse(soap, tag, id, (_CLIPSVR__ClipIsExistQueryResponse *const*)ptr, "CLIPSVR:ClipIsExistQueryResponse");
	case SOAP_TYPE_PointerTo_CLIPSVR__ClipIsExistQuery:
		return soap_out_PointerTo_CLIPSVR__ClipIsExistQuery(soap, tag, id, (_CLIPSVR__ClipIsExistQuery *const*)ptr, "CLIPSVR:ClipIsExistQuery");
	case SOAP_TYPE_PointerTo_CLIPSVR__MaterialQueryResponse:
		return soap_out_PointerTo_CLIPSVR__MaterialQueryResponse(soap, tag, id, (_CLIPSVR__MaterialQueryResponse *const*)ptr, "CLIPSVR:MaterialQueryResponse");
	case SOAP_TYPE_PointerTo_CLIPSVR__MaterialQuery:
		return soap_out_PointerTo_CLIPSVR__MaterialQuery(soap, tag, id, (_CLIPSVR__MaterialQuery *const*)ptr, "CLIPSVR:MaterialQuery");
	case SOAP_TYPE_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse:
		return soap_out_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, tag, id, (_CLIPSVR__TransferTaskExcuteResultNotifyResponse *const*)ptr, "CLIPSVR:TransferTaskExcuteResultNotifyResponse");
	case SOAP_TYPE_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify:
		return soap_out_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(soap, tag, id, (_CLIPSVR__TransferTaskExcuteResultNotify *const*)ptr, "CLIPSVR:TransferTaskExcuteResultNotify");
	case SOAP_TYPE_PointerTo_CLIPSVR__OutStorageFunctionResponse:
		return soap_out_PointerTo_CLIPSVR__OutStorageFunctionResponse(soap, tag, id, (_CLIPSVR__OutStorageFunctionResponse *const*)ptr, "CLIPSVR:OutStorageFunctionResponse");
	case SOAP_TYPE_PointerTo_CLIPSVR__OutStorageFunction:
		return soap_out_PointerTo_CLIPSVR__OutStorageFunction(soap, tag, id, (_CLIPSVR__OutStorageFunction *const*)ptr, "CLIPSVR:OutStorageFunction");
	case SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult:
		return soap_out_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult(soap, tag, id, (_ns1__ClipIsExistQueryResult_ClipArrayResult *const*)ptr, "ns1:ClipIsExistQueryResult-ClipArrayResult");
	case SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem:
		return soap_out_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, tag, id, (_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *const*)ptr, "ns1:ClipIsExistQueryResult-ClipArrayResult-ClipItem");
	case SOAP_TYPE_PointerTo_ns1__ClipExistQueryRequest_ClipArray:
		return soap_out_PointerTo_ns1__ClipExistQueryRequest_ClipArray(soap, tag, id, (_ns1__ClipExistQueryRequest_ClipArray *const*)ptr, "ns1:ClipExistQueryRequest-ClipArray");
	case SOAP_TYPE_PointerTo_ns1__MaterialQueryRequest_PlanAirDate:
		return soap_out_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(soap, tag, id, (_ns1__MaterialQueryRequest_PlanAirDate *const*)ptr, "ns1:MaterialQueryRequest-PlanAirDate");
	case SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult:
		return soap_out_PointerTo_ns1__ClipIsExistQueryResult(soap, tag, id, (_ns1__ClipIsExistQueryResult *const*)ptr, "ns1:ClipIsExistQueryResult");
	case SOAP_TYPE_PointerTo_ns1__ClipExistQueryRequest:
		return soap_out_PointerTo_ns1__ClipExistQueryRequest(soap, tag, id, (_ns1__ClipExistQueryRequest *const*)ptr, "ns1:ClipExistQueryRequest");
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfProgramBasicEntityType:
		return soap_out_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(soap, tag, id, (CLIPSVR__ArrayOfProgramBasicEntityType *const*)ptr, "CLIPSVR:ArrayOfProgramBasicEntityType");
	case SOAP_TYPE_PointerTo_ns1__MaterialQueryRequest:
		return soap_out_PointerTo_ns1__MaterialQueryRequest(soap, tag, id, (_ns1__MaterialQueryRequest *const*)ptr, "ns1:MaterialQueryRequest");
	case SOAP_TYPE_PointerToCLIPSVR__StatusDesc:
		return soap_out_PointerToCLIPSVR__StatusDesc(soap, tag, id, (CLIPSVR__StatusDesc *const*)ptr, "CLIPSVR:StatusDesc");
	case SOAP_TYPE_PointerToCLIPSVR__OutMessage:
		return soap_out_PointerToCLIPSVR__OutMessage(soap, tag, id, (CLIPSVR__OutMessage *const*)ptr, "CLIPSVR:OutMessage");
	case SOAP_TYPE_PointerTons1__ProgramBasicEntityType:
		return soap_out_PointerTons1__ProgramBasicEntityType(soap, tag, id, (ns1__ProgramBasicEntityType *const*)ptr, "ns1:ProgramBasicEntityType");
	case SOAP_TYPE_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute:
		return soap_out_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, tag, id, (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *const*)ptr, "CLIPSVR:ArrayOfExtentionAttributeTypeExtentionAttribute-ExtentionAttribute");
	case SOAP_TYPE_PointerToCLIPSVR__BreakPoint:
		return soap_out_PointerToCLIPSVR__BreakPoint(soap, tag, id, (CLIPSVR__BreakPoint *const*)ptr, "CLIPSVR:BreakPoint");
	case SOAP_TYPE_PointerToCLIPSVR__OutMessageFile:
		return soap_out_PointerToCLIPSVR__OutMessageFile(soap, tag, id, (CLIPSVR__OutMessageFile *const*)ptr, "CLIPSVR:OutMessageFile");
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute:
		return soap_out_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, tag, id, (CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *const*)ptr, "CLIPSVR:ArrayOfExtentionAttributeTypeExtentionAttribute");
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfBreakPoint:
		return soap_out_PointerToCLIPSVR__ArrayOfBreakPoint(soap, tag, id, (CLIPSVR__ArrayOfBreakPoint *const*)ptr, "CLIPSVR:ArrayOfBreakPoint");
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfOutMessageFile:
		return soap_out_PointerToCLIPSVR__ArrayOfOutMessageFile(soap, tag, id, (CLIPSVR__ArrayOfOutMessageFile *const*)ptr, "CLIPSVR:ArrayOfOutMessageFile");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem:
		((_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult:
		((_ns1__ClipIsExistQueryResult_ClipArrayResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray:
		((_ns1__ClipExistQueryRequest_ClipArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate:
		((_ns1__MaterialQueryRequest_PlanAirDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute:
		((_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns1__ClipIsExistQueryResult:
		((_ns1__ClipIsExistQueryResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ClipExistQueryRequest:
		((_ns1__ClipExistQueryRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MaterialQueryRequest:
		((_ns1__MaterialQueryRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ProgramBasicEntityType:
		((ns1__ProgramBasicEntityType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__CLIPSVR__QueryCacheResponse:
		((_CLIPSVR__QueryCacheResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__CLIPSVR__QueryCache:
		((_CLIPSVR__QueryCache *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse:
		((_CLIPSVR__ClipIsExistQueryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__CLIPSVR__ClipIsExistQuery:
		((_CLIPSVR__ClipIsExistQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__CLIPSVR__MaterialQueryResponse:
		((_CLIPSVR__MaterialQueryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__CLIPSVR__MaterialQuery:
		((_CLIPSVR__MaterialQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse:
		((_CLIPSVR__TransferTaskExcuteResultNotifyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify:
		((_CLIPSVR__TransferTaskExcuteResultNotify *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse:
		((_CLIPSVR__OutStorageFunctionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__CLIPSVR__OutStorageFunction:
		((_CLIPSVR__OutStorageFunction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType:
		((CLIPSVR__ArrayOfProgramBasicEntityType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_CLIPSVR__StatusDesc:
		((CLIPSVR__StatusDesc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute:
		((CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_CLIPSVR__BreakPoint:
		((CLIPSVR__BreakPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint:
		((CLIPSVR__ArrayOfBreakPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_CLIPSVR__OutMessageFile:
		((CLIPSVR__OutMessageFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile:
		((CLIPSVR__ArrayOfOutMessageFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_CLIPSVR__OutMessage:
		((CLIPSVR__OutMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___CLIPSVR3__QueryCache:
		soap_serialize___CLIPSVR3__QueryCache(soap, (const struct __CLIPSVR3__QueryCache *)ptr);
		break;
	case SOAP_TYPE___CLIPSVR3__ClipIsExistQuery:
		soap_serialize___CLIPSVR3__ClipIsExistQuery(soap, (const struct __CLIPSVR3__ClipIsExistQuery *)ptr);
		break;
	case SOAP_TYPE___CLIPSVR3__MaterialQuery:
		soap_serialize___CLIPSVR3__MaterialQuery(soap, (const struct __CLIPSVR3__MaterialQuery *)ptr);
		break;
	case SOAP_TYPE___CLIPSVR3__TransferTaskExcuteResultNotify:
		soap_serialize___CLIPSVR3__TransferTaskExcuteResultNotify(soap, (const struct __CLIPSVR3__TransferTaskExcuteResultNotify *)ptr);
		break;
	case SOAP_TYPE___CLIPSVR3__OutStorageFunction:
		soap_serialize___CLIPSVR3__OutStorageFunction(soap, (const struct __CLIPSVR3__OutStorageFunction *)ptr);
		break;
	case SOAP_TYPE___CLIPSVR2__QueryCache:
		soap_serialize___CLIPSVR2__QueryCache(soap, (const struct __CLIPSVR2__QueryCache *)ptr);
		break;
	case SOAP_TYPE___CLIPSVR2__ClipIsExistQuery:
		soap_serialize___CLIPSVR2__ClipIsExistQuery(soap, (const struct __CLIPSVR2__ClipIsExistQuery *)ptr);
		break;
	case SOAP_TYPE___CLIPSVR2__MaterialQuery:
		soap_serialize___CLIPSVR2__MaterialQuery(soap, (const struct __CLIPSVR2__MaterialQuery *)ptr);
		break;
	case SOAP_TYPE___CLIPSVR2__TransferTaskExcuteResultNotify:
		soap_serialize___CLIPSVR2__TransferTaskExcuteResultNotify(soap, (const struct __CLIPSVR2__TransferTaskExcuteResultNotify *)ptr);
		break;
	case SOAP_TYPE___CLIPSVR2__OutStorageFunction:
		soap_serialize___CLIPSVR2__OutStorageFunction(soap, (const struct __CLIPSVR2__OutStorageFunction *)ptr);
		break;
	case SOAP_TYPE_PointerTo_CLIPSVR__QueryCacheResponse:
		soap_serialize_PointerTo_CLIPSVR__QueryCacheResponse(soap, (_CLIPSVR__QueryCacheResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_CLIPSVR__QueryCache:
		soap_serialize_PointerTo_CLIPSVR__QueryCache(soap, (_CLIPSVR__QueryCache *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_CLIPSVR__ClipIsExistQueryResponse:
		soap_serialize_PointerTo_CLIPSVR__ClipIsExistQueryResponse(soap, (_CLIPSVR__ClipIsExistQueryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_CLIPSVR__ClipIsExistQuery:
		soap_serialize_PointerTo_CLIPSVR__ClipIsExistQuery(soap, (_CLIPSVR__ClipIsExistQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_CLIPSVR__MaterialQueryResponse:
		soap_serialize_PointerTo_CLIPSVR__MaterialQueryResponse(soap, (_CLIPSVR__MaterialQueryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_CLIPSVR__MaterialQuery:
		soap_serialize_PointerTo_CLIPSVR__MaterialQuery(soap, (_CLIPSVR__MaterialQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse:
		soap_serialize_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, (_CLIPSVR__TransferTaskExcuteResultNotifyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify:
		soap_serialize_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(soap, (_CLIPSVR__TransferTaskExcuteResultNotify *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_CLIPSVR__OutStorageFunctionResponse:
		soap_serialize_PointerTo_CLIPSVR__OutStorageFunctionResponse(soap, (_CLIPSVR__OutStorageFunctionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_CLIPSVR__OutStorageFunction:
		soap_serialize_PointerTo_CLIPSVR__OutStorageFunction(soap, (_CLIPSVR__OutStorageFunction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult:
		soap_serialize_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult(soap, (_ns1__ClipIsExistQueryResult_ClipArrayResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem:
		soap_serialize_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, (_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ClipExistQueryRequest_ClipArray:
		soap_serialize_PointerTo_ns1__ClipExistQueryRequest_ClipArray(soap, (_ns1__ClipExistQueryRequest_ClipArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__MaterialQueryRequest_PlanAirDate:
		soap_serialize_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(soap, (_ns1__MaterialQueryRequest_PlanAirDate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult:
		soap_serialize_PointerTo_ns1__ClipIsExistQueryResult(soap, (_ns1__ClipIsExistQueryResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ClipExistQueryRequest:
		soap_serialize_PointerTo_ns1__ClipExistQueryRequest(soap, (_ns1__ClipExistQueryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfProgramBasicEntityType:
		soap_serialize_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(soap, (CLIPSVR__ArrayOfProgramBasicEntityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__MaterialQueryRequest:
		soap_serialize_PointerTo_ns1__MaterialQueryRequest(soap, (_ns1__MaterialQueryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCLIPSVR__StatusDesc:
		soap_serialize_PointerToCLIPSVR__StatusDesc(soap, (CLIPSVR__StatusDesc *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCLIPSVR__OutMessage:
		soap_serialize_PointerToCLIPSVR__OutMessage(soap, (CLIPSVR__OutMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProgramBasicEntityType:
		soap_serialize_PointerTons1__ProgramBasicEntityType(soap, (ns1__ProgramBasicEntityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute:
		soap_serialize_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCLIPSVR__BreakPoint:
		soap_serialize_PointerToCLIPSVR__BreakPoint(soap, (CLIPSVR__BreakPoint *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCLIPSVR__OutMessageFile:
		soap_serialize_PointerToCLIPSVR__OutMessageFile(soap, (CLIPSVR__OutMessageFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute:
		soap_serialize_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, (CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfBreakPoint:
		soap_serialize_PointerToCLIPSVR__ArrayOfBreakPoint(soap, (CLIPSVR__ArrayOfBreakPoint *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCLIPSVR__ArrayOfOutMessageFile:
		soap_serialize_PointerToCLIPSVR__ArrayOfOutMessageFile(soap, (CLIPSVR__ArrayOfOutMessageFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_CLIPSVR__OutMessage:
		return (void*)soap_instantiate_CLIPSVR__OutMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile:
		return (void*)soap_instantiate_CLIPSVR__ArrayOfOutMessageFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_CLIPSVR__OutMessageFile:
		return (void*)soap_instantiate_CLIPSVR__OutMessageFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint:
		return (void*)soap_instantiate_CLIPSVR__ArrayOfBreakPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_CLIPSVR__BreakPoint:
		return (void*)soap_instantiate_CLIPSVR__BreakPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute:
		return (void*)soap_instantiate__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute:
		return (void*)soap_instantiate_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_CLIPSVR__StatusDesc:
		return (void*)soap_instantiate_CLIPSVR__StatusDesc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType:
		return (void*)soap_instantiate_CLIPSVR__ArrayOfProgramBasicEntityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__CLIPSVR__OutStorageFunction:
		return (void*)soap_instantiate__CLIPSVR__OutStorageFunction(soap, -1, type, arrayType, n);
	case SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse:
		return (void*)soap_instantiate__CLIPSVR__OutStorageFunctionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify:
		return (void*)soap_instantiate__CLIPSVR__TransferTaskExcuteResultNotify(soap, -1, type, arrayType, n);
	case SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse:
		return (void*)soap_instantiate__CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__CLIPSVR__MaterialQuery:
		return (void*)soap_instantiate__CLIPSVR__MaterialQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE__CLIPSVR__MaterialQueryResponse:
		return (void*)soap_instantiate__CLIPSVR__MaterialQueryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__CLIPSVR__ClipIsExistQuery:
		return (void*)soap_instantiate__CLIPSVR__ClipIsExistQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse:
		return (void*)soap_instantiate__CLIPSVR__ClipIsExistQueryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__CLIPSVR__QueryCache:
		return (void*)soap_instantiate__CLIPSVR__QueryCache(soap, -1, type, arrayType, n);
	case SOAP_TYPE__CLIPSVR__QueryCacheResponse:
		return (void*)soap_instantiate__CLIPSVR__QueryCacheResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ProgramBasicEntityType:
		return (void*)soap_instantiate_ns1__ProgramBasicEntityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate:
		return (void*)soap_instantiate__ns1__MaterialQueryRequest_PlanAirDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MaterialQueryRequest:
		return (void*)soap_instantiate__ns1__MaterialQueryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray:
		return (void*)soap_instantiate__ns1__ClipExistQueryRequest_ClipArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ClipExistQueryRequest:
		return (void*)soap_instantiate__ns1__ClipExistQueryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem:
		return (void*)soap_instantiate__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult:
		return (void*)soap_instantiate__ns1__ClipIsExistQueryResult_ClipArrayResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ClipIsExistQueryResult:
		return (void*)soap_instantiate__ns1__ClipIsExistQueryResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE___CLIPSVR2__OutStorageFunction:
		return (void*)soap_instantiate___CLIPSVR2__OutStorageFunction(soap, -1, type, arrayType, n);
	case SOAP_TYPE___CLIPSVR2__TransferTaskExcuteResultNotify:
		return (void*)soap_instantiate___CLIPSVR2__TransferTaskExcuteResultNotify(soap, -1, type, arrayType, n);
	case SOAP_TYPE___CLIPSVR2__MaterialQuery:
		return (void*)soap_instantiate___CLIPSVR2__MaterialQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___CLIPSVR2__ClipIsExistQuery:
		return (void*)soap_instantiate___CLIPSVR2__ClipIsExistQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___CLIPSVR2__QueryCache:
		return (void*)soap_instantiate___CLIPSVR2__QueryCache(soap, -1, type, arrayType, n);
	case SOAP_TYPE___CLIPSVR3__OutStorageFunction:
		return (void*)soap_instantiate___CLIPSVR3__OutStorageFunction(soap, -1, type, arrayType, n);
	case SOAP_TYPE___CLIPSVR3__TransferTaskExcuteResultNotify:
		return (void*)soap_instantiate___CLIPSVR3__TransferTaskExcuteResultNotify(soap, -1, type, arrayType, n);
	case SOAP_TYPE___CLIPSVR3__MaterialQuery:
		return (void*)soap_instantiate___CLIPSVR3__MaterialQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___CLIPSVR3__ClipIsExistQuery:
		return (void*)soap_instantiate___CLIPSVR3__ClipIsExistQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___CLIPSVR3__QueryCache:
		return (void*)soap_instantiate___CLIPSVR3__QueryCache(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_CLIPSVR__OutMessage:
		if (p->size < 0)
			delete (CLIPSVR__OutMessage*)p->ptr;
		else
			delete[] (CLIPSVR__OutMessage*)p->ptr;
		break;
	case SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile:
		if (p->size < 0)
			delete (CLIPSVR__ArrayOfOutMessageFile*)p->ptr;
		else
			delete[] (CLIPSVR__ArrayOfOutMessageFile*)p->ptr;
		break;
	case SOAP_TYPE_CLIPSVR__OutMessageFile:
		if (p->size < 0)
			delete (CLIPSVR__OutMessageFile*)p->ptr;
		else
			delete[] (CLIPSVR__OutMessageFile*)p->ptr;
		break;
	case SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint:
		if (p->size < 0)
			delete (CLIPSVR__ArrayOfBreakPoint*)p->ptr;
		else
			delete[] (CLIPSVR__ArrayOfBreakPoint*)p->ptr;
		break;
	case SOAP_TYPE_CLIPSVR__BreakPoint:
		if (p->size < 0)
			delete (CLIPSVR__BreakPoint*)p->ptr;
		else
			delete[] (CLIPSVR__BreakPoint*)p->ptr;
		break;
	case SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute:
		if (p->size < 0)
			delete (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute*)p->ptr;
		else
			delete[] (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute*)p->ptr;
		break;
	case SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute:
		if (p->size < 0)
			delete (CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute*)p->ptr;
		else
			delete[] (CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute*)p->ptr;
		break;
	case SOAP_TYPE_CLIPSVR__StatusDesc:
		if (p->size < 0)
			delete (CLIPSVR__StatusDesc*)p->ptr;
		else
			delete[] (CLIPSVR__StatusDesc*)p->ptr;
		break;
	case SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType:
		if (p->size < 0)
			delete (CLIPSVR__ArrayOfProgramBasicEntityType*)p->ptr;
		else
			delete[] (CLIPSVR__ArrayOfProgramBasicEntityType*)p->ptr;
		break;
	case SOAP_TYPE__CLIPSVR__OutStorageFunction:
		if (p->size < 0)
			delete (_CLIPSVR__OutStorageFunction*)p->ptr;
		else
			delete[] (_CLIPSVR__OutStorageFunction*)p->ptr;
		break;
	case SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse:
		if (p->size < 0)
			delete (_CLIPSVR__OutStorageFunctionResponse*)p->ptr;
		else
			delete[] (_CLIPSVR__OutStorageFunctionResponse*)p->ptr;
		break;
	case SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify:
		if (p->size < 0)
			delete (_CLIPSVR__TransferTaskExcuteResultNotify*)p->ptr;
		else
			delete[] (_CLIPSVR__TransferTaskExcuteResultNotify*)p->ptr;
		break;
	case SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse:
		if (p->size < 0)
			delete (_CLIPSVR__TransferTaskExcuteResultNotifyResponse*)p->ptr;
		else
			delete[] (_CLIPSVR__TransferTaskExcuteResultNotifyResponse*)p->ptr;
		break;
	case SOAP_TYPE__CLIPSVR__MaterialQuery:
		if (p->size < 0)
			delete (_CLIPSVR__MaterialQuery*)p->ptr;
		else
			delete[] (_CLIPSVR__MaterialQuery*)p->ptr;
		break;
	case SOAP_TYPE__CLIPSVR__MaterialQueryResponse:
		if (p->size < 0)
			delete (_CLIPSVR__MaterialQueryResponse*)p->ptr;
		else
			delete[] (_CLIPSVR__MaterialQueryResponse*)p->ptr;
		break;
	case SOAP_TYPE__CLIPSVR__ClipIsExistQuery:
		if (p->size < 0)
			delete (_CLIPSVR__ClipIsExistQuery*)p->ptr;
		else
			delete[] (_CLIPSVR__ClipIsExistQuery*)p->ptr;
		break;
	case SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse:
		if (p->size < 0)
			delete (_CLIPSVR__ClipIsExistQueryResponse*)p->ptr;
		else
			delete[] (_CLIPSVR__ClipIsExistQueryResponse*)p->ptr;
		break;
	case SOAP_TYPE__CLIPSVR__QueryCache:
		if (p->size < 0)
			delete (_CLIPSVR__QueryCache*)p->ptr;
		else
			delete[] (_CLIPSVR__QueryCache*)p->ptr;
		break;
	case SOAP_TYPE__CLIPSVR__QueryCacheResponse:
		if (p->size < 0)
			delete (_CLIPSVR__QueryCacheResponse*)p->ptr;
		else
			delete[] (_CLIPSVR__QueryCacheResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ProgramBasicEntityType:
		if (p->size < 0)
			delete (ns1__ProgramBasicEntityType*)p->ptr;
		else
			delete[] (ns1__ProgramBasicEntityType*)p->ptr;
		break;
	case SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate:
		if (p->size < 0)
			delete (_ns1__MaterialQueryRequest_PlanAirDate*)p->ptr;
		else
			delete[] (_ns1__MaterialQueryRequest_PlanAirDate*)p->ptr;
		break;
	case SOAP_TYPE__ns1__MaterialQueryRequest:
		if (p->size < 0)
			delete (_ns1__MaterialQueryRequest*)p->ptr;
		else
			delete[] (_ns1__MaterialQueryRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray:
		if (p->size < 0)
			delete (_ns1__ClipExistQueryRequest_ClipArray*)p->ptr;
		else
			delete[] (_ns1__ClipExistQueryRequest_ClipArray*)p->ptr;
		break;
	case SOAP_TYPE__ns1__ClipExistQueryRequest:
		if (p->size < 0)
			delete (_ns1__ClipExistQueryRequest*)p->ptr;
		else
			delete[] (_ns1__ClipExistQueryRequest*)p->ptr;
		break;
	case SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem:
		if (p->size < 0)
			delete (_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem*)p->ptr;
		else
			delete[] (_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem*)p->ptr;
		break;
	case SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult:
		if (p->size < 0)
			delete (_ns1__ClipIsExistQueryResult_ClipArrayResult*)p->ptr;
		else
			delete[] (_ns1__ClipIsExistQueryResult_ClipArrayResult*)p->ptr;
		break;
	case SOAP_TYPE__ns1__ClipIsExistQueryResult:
		if (p->size < 0)
			delete (_ns1__ClipIsExistQueryResult*)p->ptr;
		else
			delete[] (_ns1__ClipIsExistQueryResult*)p->ptr;
		break;
	case SOAP_TYPE___CLIPSVR2__OutStorageFunction:
		if (p->size < 0)
			delete (struct __CLIPSVR2__OutStorageFunction*)p->ptr;
		else
			delete[] (struct __CLIPSVR2__OutStorageFunction*)p->ptr;
		break;
	case SOAP_TYPE___CLIPSVR2__TransferTaskExcuteResultNotify:
		if (p->size < 0)
			delete (struct __CLIPSVR2__TransferTaskExcuteResultNotify*)p->ptr;
		else
			delete[] (struct __CLIPSVR2__TransferTaskExcuteResultNotify*)p->ptr;
		break;
	case SOAP_TYPE___CLIPSVR2__MaterialQuery:
		if (p->size < 0)
			delete (struct __CLIPSVR2__MaterialQuery*)p->ptr;
		else
			delete[] (struct __CLIPSVR2__MaterialQuery*)p->ptr;
		break;
	case SOAP_TYPE___CLIPSVR2__ClipIsExistQuery:
		if (p->size < 0)
			delete (struct __CLIPSVR2__ClipIsExistQuery*)p->ptr;
		else
			delete[] (struct __CLIPSVR2__ClipIsExistQuery*)p->ptr;
		break;
	case SOAP_TYPE___CLIPSVR2__QueryCache:
		if (p->size < 0)
			delete (struct __CLIPSVR2__QueryCache*)p->ptr;
		else
			delete[] (struct __CLIPSVR2__QueryCache*)p->ptr;
		break;
	case SOAP_TYPE___CLIPSVR3__OutStorageFunction:
		if (p->size < 0)
			delete (struct __CLIPSVR3__OutStorageFunction*)p->ptr;
		else
			delete[] (struct __CLIPSVR3__OutStorageFunction*)p->ptr;
		break;
	case SOAP_TYPE___CLIPSVR3__TransferTaskExcuteResultNotify:
		if (p->size < 0)
			delete (struct __CLIPSVR3__TransferTaskExcuteResultNotify*)p->ptr;
		else
			delete[] (struct __CLIPSVR3__TransferTaskExcuteResultNotify*)p->ptr;
		break;
	case SOAP_TYPE___CLIPSVR3__MaterialQuery:
		if (p->size < 0)
			delete (struct __CLIPSVR3__MaterialQuery*)p->ptr;
		else
			delete[] (struct __CLIPSVR3__MaterialQuery*)p->ptr;
		break;
	case SOAP_TYPE___CLIPSVR3__ClipIsExistQuery:
		if (p->size < 0)
			delete (struct __CLIPSVR3__ClipIsExistQuery*)p->ptr;
		else
			delete[] (struct __CLIPSVR3__ClipIsExistQuery*)p->ptr;
		break;
	case SOAP_TYPE___CLIPSVR3__QueryCache:
		if (p->size < 0)
			delete (struct __CLIPSVR3__QueryCache*)p->ptr;
		else
			delete[] (struct __CLIPSVR3__QueryCache*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType:
		if (p->size < 0)
			delete (std::vector<ns1__ProgramBasicEntityType * >*)p->ptr;
		else
			delete[] (std::vector<ns1__ProgramBasicEntityType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint:
		if (p->size < 0)
			delete (std::vector<CLIPSVR__BreakPoint * >*)p->ptr;
		else
			delete[] (std::vector<CLIPSVR__BreakPoint * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile:
		if (p->size < 0)
			delete (std::vector<CLIPSVR__OutMessageFile * >*)p->ptr;
		else
			delete[] (std::vector<CLIPSVR__OutMessageFile * >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__ProgramBasicEntityType * >*)p)[len] = *(ns1__ProgramBasicEntityType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<CLIPSVR__BreakPoint * >*)p)[len] = *(CLIPSVR__BreakPoint **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<CLIPSVR__OutMessageFile * >*)p)[len] = *(CLIPSVR__OutMessageFile **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem::ClipPrimaryID = NULL;
}

void _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem::ClipPrimaryID);
}

int _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(struct soap *soap, const char *tag, int id, const _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ClipPrimaryID", -1, &(a->_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem::ClipPrimaryID), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem * SOAP_FMAC4 soap_get__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(struct soap *soap, _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem * SOAP_FMAC4 soap_in__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(struct soap *soap, const char *tag, _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem, sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ClipPrimaryID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ClipPrimaryID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:ClipPrimaryID", &(a->_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem::ClipPrimaryID), "xsd:string"))
				{	soap_flag_ClipPrimaryID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem, 0, sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem), 0, soap_copy__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ClipPrimaryID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem * SOAP_FMAC4 soap_instantiate__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem;
		if (size)
			*size = sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem);
	}
	else
	{	cp->ptr = (void*)new _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem %p -> %p\n", q, p));
	*(_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem*)p = *(_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem*)q;
}

void _ns1__ClipIsExistQueryResult_ClipArrayResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__ClipIsExistQueryResult_ClipArrayResult::ClipItem = NULL;
	soap_default_bool(soap, &this->_ns1__ClipIsExistQueryResult_ClipArrayResult::IsExist);
	soap_default_int(soap, &this->_ns1__ClipIsExistQueryResult_ClipArrayResult::Statue);
	this->_ns1__ClipIsExistQueryResult_ClipArrayResult::Description = NULL;
}

void _ns1__ClipIsExistQueryResult_ClipArrayResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, &this->_ns1__ClipIsExistQueryResult_ClipArrayResult::ClipItem);
	soap_embedded(soap, &this->_ns1__ClipIsExistQueryResult_ClipArrayResult::Statue, SOAP_TYPE_int);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ClipIsExistQueryResult_ClipArrayResult::Description);
}

int _ns1__ClipIsExistQueryResult_ClipArrayResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__ClipIsExistQueryResult_ClipArrayResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ClipIsExistQueryResult_ClipArrayResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ClipIsExistQueryResult_ClipArrayResult(struct soap *soap, const char *tag, int id, const _ns1__ClipIsExistQueryResult_ClipArrayResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, "ns1:ClipItem", -1, &(a->_ns1__ClipIsExistQueryResult_ClipArrayResult::ClipItem), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsExist", -1, &(a->_ns1__ClipIsExistQueryResult_ClipArrayResult::IsExist), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Statue", -1, &(a->_ns1__ClipIsExistQueryResult_ClipArrayResult::Statue), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Description", -1, &(a->_ns1__ClipIsExistQueryResult_ClipArrayResult::Description), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ClipIsExistQueryResult_ClipArrayResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ClipIsExistQueryResult_ClipArrayResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult_ClipArrayResult * SOAP_FMAC4 soap_get__ns1__ClipIsExistQueryResult_ClipArrayResult(struct soap *soap, _ns1__ClipIsExistQueryResult_ClipArrayResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ClipIsExistQueryResult_ClipArrayResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__ClipIsExistQueryResult_ClipArrayResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ClipIsExistQueryResult_ClipArrayResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult_ClipArrayResult * SOAP_FMAC4 soap_in__ns1__ClipIsExistQueryResult_ClipArrayResult(struct soap *soap, const char *tag, _ns1__ClipIsExistQueryResult_ClipArrayResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ClipIsExistQueryResult_ClipArrayResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult, sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ClipIsExistQueryResult_ClipArrayResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ClipItem1 = 1;
	size_t soap_flag_IsExist1 = 1;
	size_t soap_flag_Statue1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ClipItem1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, "ns1:ClipItem", &(a->_ns1__ClipIsExistQueryResult_ClipArrayResult::ClipItem), ""))
				{	soap_flag_ClipItem1--;
					continue;
				}
			if (soap_flag_IsExist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsExist", &(a->_ns1__ClipIsExistQueryResult_ClipArrayResult::IsExist), "xsd:boolean"))
				{	soap_flag_IsExist1--;
					continue;
				}
			if (soap_flag_Statue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Statue", &(a->_ns1__ClipIsExistQueryResult_ClipArrayResult::Statue), "xsd:int"))
				{	soap_flag_Statue1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Description", &(a->_ns1__ClipIsExistQueryResult_ClipArrayResult::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ClipIsExistQueryResult_ClipArrayResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult, 0, sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult), 0, soap_copy__ns1__ClipIsExistQueryResult_ClipArrayResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ClipItem1 > 0 || soap_flag_IsExist1 > 0 || soap_flag_Statue1 > 0 || soap_flag_Description1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult_ClipArrayResult * SOAP_FMAC4 soap_instantiate__ns1__ClipIsExistQueryResult_ClipArrayResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ClipIsExistQueryResult_ClipArrayResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__ClipIsExistQueryResult_ClipArrayResult;
		if (size)
			*size = sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult);
	}
	else
	{	cp->ptr = (void*)new _ns1__ClipIsExistQueryResult_ClipArrayResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ClipIsExistQueryResult_ClipArrayResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ClipIsExistQueryResult_ClipArrayResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ClipIsExistQueryResult_ClipArrayResult %p -> %p\n", q, p));
	*(_ns1__ClipIsExistQueryResult_ClipArrayResult*)p = *(_ns1__ClipIsExistQueryResult_ClipArrayResult*)q;
}

void _ns1__ClipExistQueryRequest_ClipArray::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__ClipExistQueryRequest_ClipArray::ClipPrimaryID = NULL;
}

void _ns1__ClipExistQueryRequest_ClipArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ClipExistQueryRequest_ClipArray::ClipPrimaryID);
}

int _ns1__ClipExistQueryRequest_ClipArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__ClipExistQueryRequest_ClipArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ClipExistQueryRequest_ClipArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ClipExistQueryRequest_ClipArray(struct soap *soap, const char *tag, int id, const _ns1__ClipExistQueryRequest_ClipArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ClipPrimaryID", -1, &(a->_ns1__ClipExistQueryRequest_ClipArray::ClipPrimaryID), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ClipExistQueryRequest_ClipArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ClipExistQueryRequest_ClipArray(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ClipExistQueryRequest_ClipArray * SOAP_FMAC4 soap_get__ns1__ClipExistQueryRequest_ClipArray(struct soap *soap, _ns1__ClipExistQueryRequest_ClipArray *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ClipExistQueryRequest_ClipArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__ClipExistQueryRequest_ClipArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ClipExistQueryRequest_ClipArray(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ClipExistQueryRequest_ClipArray * SOAP_FMAC4 soap_in__ns1__ClipExistQueryRequest_ClipArray(struct soap *soap, const char *tag, _ns1__ClipExistQueryRequest_ClipArray *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ClipExistQueryRequest_ClipArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray, sizeof(_ns1__ClipExistQueryRequest_ClipArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ClipExistQueryRequest_ClipArray *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ClipPrimaryID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ClipPrimaryID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:ClipPrimaryID", &(a->_ns1__ClipExistQueryRequest_ClipArray::ClipPrimaryID), "xsd:string"))
				{	soap_flag_ClipPrimaryID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ClipExistQueryRequest_ClipArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray, 0, sizeof(_ns1__ClipExistQueryRequest_ClipArray), 0, soap_copy__ns1__ClipExistQueryRequest_ClipArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ClipPrimaryID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__ClipExistQueryRequest_ClipArray * SOAP_FMAC4 soap_instantiate__ns1__ClipExistQueryRequest_ClipArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ClipExistQueryRequest_ClipArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__ClipExistQueryRequest_ClipArray;
		if (size)
			*size = sizeof(_ns1__ClipExistQueryRequest_ClipArray);
	}
	else
	{	cp->ptr = (void*)new _ns1__ClipExistQueryRequest_ClipArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ClipExistQueryRequest_ClipArray);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ClipExistQueryRequest_ClipArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ClipExistQueryRequest_ClipArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ClipExistQueryRequest_ClipArray %p -> %p\n", q, p));
	*(_ns1__ClipExistQueryRequest_ClipArray*)p = *(_ns1__ClipExistQueryRequest_ClipArray*)q;
}

void _ns1__MaterialQueryRequest_PlanAirDate::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__MaterialQueryRequest_PlanAirDate::From = NULL;
	this->_ns1__MaterialQueryRequest_PlanAirDate::To = NULL;
}

void _ns1__MaterialQueryRequest_PlanAirDate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__MaterialQueryRequest_PlanAirDate::From);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__MaterialQueryRequest_PlanAirDate::To);
}

int _ns1__MaterialQueryRequest_PlanAirDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__MaterialQueryRequest_PlanAirDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MaterialQueryRequest_PlanAirDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MaterialQueryRequest_PlanAirDate(struct soap *soap, const char *tag, int id, const _ns1__MaterialQueryRequest_PlanAirDate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:From", -1, &(a->_ns1__MaterialQueryRequest_PlanAirDate::From), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:To", -1, &(a->_ns1__MaterialQueryRequest_PlanAirDate::To), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MaterialQueryRequest_PlanAirDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MaterialQueryRequest_PlanAirDate(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MaterialQueryRequest_PlanAirDate * SOAP_FMAC4 soap_get__ns1__MaterialQueryRequest_PlanAirDate(struct soap *soap, _ns1__MaterialQueryRequest_PlanAirDate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MaterialQueryRequest_PlanAirDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__MaterialQueryRequest_PlanAirDate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MaterialQueryRequest_PlanAirDate(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MaterialQueryRequest_PlanAirDate * SOAP_FMAC4 soap_in__ns1__MaterialQueryRequest_PlanAirDate(struct soap *soap, const char *tag, _ns1__MaterialQueryRequest_PlanAirDate *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MaterialQueryRequest_PlanAirDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate, sizeof(_ns1__MaterialQueryRequest_PlanAirDate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__MaterialQueryRequest_PlanAirDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_From1 = 1;
	size_t soap_flag_To1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_From1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:From", &(a->_ns1__MaterialQueryRequest_PlanAirDate::From), "xsd:string"))
				{	soap_flag_From1--;
					continue;
				}
			if (soap_flag_To1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:To", &(a->_ns1__MaterialQueryRequest_PlanAirDate::To), "xsd:string"))
				{	soap_flag_To1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MaterialQueryRequest_PlanAirDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate, 0, sizeof(_ns1__MaterialQueryRequest_PlanAirDate), 0, soap_copy__ns1__MaterialQueryRequest_PlanAirDate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__MaterialQueryRequest_PlanAirDate * SOAP_FMAC4 soap_instantiate__ns1__MaterialQueryRequest_PlanAirDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MaterialQueryRequest_PlanAirDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__MaterialQueryRequest_PlanAirDate;
		if (size)
			*size = sizeof(_ns1__MaterialQueryRequest_PlanAirDate);
	}
	else
	{	cp->ptr = (void*)new _ns1__MaterialQueryRequest_PlanAirDate[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__MaterialQueryRequest_PlanAirDate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__MaterialQueryRequest_PlanAirDate*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__MaterialQueryRequest_PlanAirDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__MaterialQueryRequest_PlanAirDate %p -> %p\n", q, p));
	*(_ns1__MaterialQueryRequest_PlanAirDate*)p = *(_ns1__MaterialQueryRequest_PlanAirDate*)q;
}

void _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::ItemCode = NULL;
	this->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::ItemName = NULL;
	this->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::Value = NULL;
}

void _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::ItemCode);
	soap_serialize_PointerTostd__string(soap, &this->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::ItemName);
	soap_serialize_PointerTostd__string(soap, &this->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::Value);
}

int _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(struct soap *soap, const char *tag, int id, const _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:ItemCode", -1, &(a->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::ItemCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:ItemName", -1, &(a->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::ItemName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:Value", -1, &(a->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::Value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, this, tag, type);
}

SOAP_FMAC3 _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute * SOAP_FMAC4 soap_get__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(struct soap *soap, _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *p, const char *tag, const char *type)
{
	if ((p = soap_in__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, tag, this, type);
}

SOAP_FMAC3 _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute * SOAP_FMAC4 soap_in__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(struct soap *soap, const char *tag, _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute, sizeof(_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ItemCode1 = 1;
	size_t soap_flag_ItemName1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ItemCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:ItemCode", &(a->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::ItemCode), "xsd:string"))
				{	soap_flag_ItemCode1--;
					continue;
				}
			if (soap_flag_ItemName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:ItemName", &(a->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::ItemName), "xsd:string"))
				{	soap_flag_ItemName1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:Value", &(a->_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute::Value), "xsd:string"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute, 0, sizeof(_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute), 0, soap_copy__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute * SOAP_FMAC4 soap_instantiate__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute;
		if (size)
			*size = sizeof(_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute);
	}
	else
	{	cp->ptr = (void*)new _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute %p -> %p\n", q, p));
	*(_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute*)p = *(_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _ns1__ClipIsExistQueryResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ClipIsExistQueryResult::__sizeClipArrayResult = 0;
	this->_ns1__ClipIsExistQueryResult::ClipArrayResult = NULL;
	/* transient soap skipped */
}

void _ns1__ClipIsExistQueryResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__ClipIsExistQueryResult::ClipArrayResult)
	{	int i;
		for (i = 0; i < this->_ns1__ClipIsExistQueryResult::__sizeClipArrayResult; i++)
		{
			soap_embedded(soap, this->_ns1__ClipIsExistQueryResult::ClipArrayResult + i, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult);
			this->_ns1__ClipIsExistQueryResult::ClipArrayResult[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int _ns1__ClipIsExistQueryResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ClipIsExistQueryResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__ClipIsExistQueryResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ClipIsExistQueryResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ClipIsExistQueryResult(struct soap *soap, const char *tag, int id, const _ns1__ClipIsExistQueryResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ClipIsExistQueryResult), type))
		return soap->error;
	if (a->_ns1__ClipIsExistQueryResult::ClipArrayResult)
	{	int i;
		for (i = 0; i < a->_ns1__ClipIsExistQueryResult::__sizeClipArrayResult; i++)
			if (a->_ns1__ClipIsExistQueryResult::ClipArrayResult[i].soap_out(soap, "ns1:ClipArrayResult", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ClipIsExistQueryResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ClipIsExistQueryResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult * SOAP_FMAC4 soap_get__ns1__ClipIsExistQueryResult(struct soap *soap, _ns1__ClipIsExistQueryResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ClipIsExistQueryResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__ClipIsExistQueryResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ClipIsExistQueryResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult * SOAP_FMAC4 soap_in__ns1__ClipIsExistQueryResult(struct soap *soap, const char *tag, _ns1__ClipIsExistQueryResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ClipIsExistQueryResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ClipIsExistQueryResult, sizeof(_ns1__ClipIsExistQueryResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ClipIsExistQueryResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ClipIsExistQueryResult *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ClipArrayResult1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ClipArrayResult", 1, NULL))
			{	if (a->_ns1__ClipIsExistQueryResult::ClipArrayResult == NULL)
				{	if (soap_blist_ClipArrayResult1 == NULL)
						soap_blist_ClipArrayResult1 = soap_new_block(soap);
					a->_ns1__ClipIsExistQueryResult::ClipArrayResult = (_ns1__ClipIsExistQueryResult_ClipArrayResult *)soap_push_block(soap, soap_blist_ClipArrayResult1, sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult));
					if (a->_ns1__ClipIsExistQueryResult::ClipArrayResult == NULL)
						return NULL;
					_ns1__ClipIsExistQueryResult_ClipArrayResult p;
					memcpy(a->_ns1__ClipIsExistQueryResult::ClipArrayResult, &p, sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult)); // a bit rough but portable
					a->_ns1__ClipIsExistQueryResult::ClipArrayResult->soap_default(soap);
				}soap_revert(soap);
				if (soap_in__ns1__ClipIsExistQueryResult_ClipArrayResult(soap, "ns1:ClipArrayResult", a->_ns1__ClipIsExistQueryResult::ClipArrayResult, ""))
				{	a->_ns1__ClipIsExistQueryResult::__sizeClipArrayResult++;
					a->_ns1__ClipIsExistQueryResult::ClipArrayResult = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__ClipIsExistQueryResult::ClipArrayResult)
			soap_pop_block(soap, soap_blist_ClipArrayResult1);
		if (a->_ns1__ClipIsExistQueryResult::__sizeClipArrayResult)
			a->_ns1__ClipIsExistQueryResult::ClipArrayResult = (_ns1__ClipIsExistQueryResult_ClipArrayResult *)soap_save_block(soap, soap_blist_ClipArrayResult1, NULL, 1);
		else
		{	a->_ns1__ClipIsExistQueryResult::ClipArrayResult = NULL;
			if (soap_blist_ClipArrayResult1)
				soap_end_block(soap, soap_blist_ClipArrayResult1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ClipIsExistQueryResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ClipIsExistQueryResult, 0, sizeof(_ns1__ClipIsExistQueryResult), 0, soap_copy__ns1__ClipIsExistQueryResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult * SOAP_FMAC4 soap_instantiate__ns1__ClipIsExistQueryResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ClipIsExistQueryResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ClipIsExistQueryResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__ClipIsExistQueryResult;
		if (size)
			*size = sizeof(_ns1__ClipIsExistQueryResult);
		((_ns1__ClipIsExistQueryResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__ClipIsExistQueryResult[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ClipIsExistQueryResult);
		for (int i = 0; i < n; i++)
			((_ns1__ClipIsExistQueryResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ClipIsExistQueryResult*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ClipIsExistQueryResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ClipIsExistQueryResult %p -> %p\n", q, p));
	*(_ns1__ClipIsExistQueryResult*)p = *(_ns1__ClipIsExistQueryResult*)q;
}

void _ns1__ClipExistQueryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ClipExistQueryRequest::__sizeClipArray = 0;
	this->_ns1__ClipExistQueryRequest::ClipArray = NULL;
	/* transient soap skipped */
}

void _ns1__ClipExistQueryRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__ClipExistQueryRequest::ClipArray)
	{	int i;
		for (i = 0; i < this->_ns1__ClipExistQueryRequest::__sizeClipArray; i++)
		{
			soap_embedded(soap, this->_ns1__ClipExistQueryRequest::ClipArray + i, SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray);
			this->_ns1__ClipExistQueryRequest::ClipArray[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int _ns1__ClipExistQueryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ClipExistQueryRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__ClipExistQueryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ClipExistQueryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ClipExistQueryRequest(struct soap *soap, const char *tag, int id, const _ns1__ClipExistQueryRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ClipExistQueryRequest), type))
		return soap->error;
	if (a->_ns1__ClipExistQueryRequest::ClipArray)
	{	int i;
		for (i = 0; i < a->_ns1__ClipExistQueryRequest::__sizeClipArray; i++)
			if (a->_ns1__ClipExistQueryRequest::ClipArray[i].soap_out(soap, "ns1:ClipArray", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ClipExistQueryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ClipExistQueryRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ClipExistQueryRequest * SOAP_FMAC4 soap_get__ns1__ClipExistQueryRequest(struct soap *soap, _ns1__ClipExistQueryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ClipExistQueryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__ClipExistQueryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ClipExistQueryRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ClipExistQueryRequest * SOAP_FMAC4 soap_in__ns1__ClipExistQueryRequest(struct soap *soap, const char *tag, _ns1__ClipExistQueryRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ClipExistQueryRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ClipExistQueryRequest, sizeof(_ns1__ClipExistQueryRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ClipExistQueryRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ClipExistQueryRequest *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ClipArray1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:ClipArray", 1, NULL))
			{	if (a->_ns1__ClipExistQueryRequest::ClipArray == NULL)
				{	if (soap_blist_ClipArray1 == NULL)
						soap_blist_ClipArray1 = soap_new_block(soap);
					a->_ns1__ClipExistQueryRequest::ClipArray = (_ns1__ClipExistQueryRequest_ClipArray *)soap_push_block(soap, soap_blist_ClipArray1, sizeof(_ns1__ClipExistQueryRequest_ClipArray));
					if (a->_ns1__ClipExistQueryRequest::ClipArray == NULL)
						return NULL;
					_ns1__ClipExistQueryRequest_ClipArray p;
					memcpy(a->_ns1__ClipExistQueryRequest::ClipArray, &p, sizeof(_ns1__ClipExistQueryRequest_ClipArray)); // a bit rough but portable
					a->_ns1__ClipExistQueryRequest::ClipArray->soap_default(soap);
				}soap_revert(soap);
				if (soap_in__ns1__ClipExistQueryRequest_ClipArray(soap, "ns1:ClipArray", a->_ns1__ClipExistQueryRequest::ClipArray, ""))
				{	a->_ns1__ClipExistQueryRequest::__sizeClipArray++;
					a->_ns1__ClipExistQueryRequest::ClipArray = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__ClipExistQueryRequest::ClipArray)
			soap_pop_block(soap, soap_blist_ClipArray1);
		if (a->_ns1__ClipExistQueryRequest::__sizeClipArray)
			a->_ns1__ClipExistQueryRequest::ClipArray = (_ns1__ClipExistQueryRequest_ClipArray *)soap_save_block(soap, soap_blist_ClipArray1, NULL, 1);
		else
		{	a->_ns1__ClipExistQueryRequest::ClipArray = NULL;
			if (soap_blist_ClipArray1)
				soap_end_block(soap, soap_blist_ClipArray1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ClipExistQueryRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ClipExistQueryRequest, 0, sizeof(_ns1__ClipExistQueryRequest), 0, soap_copy__ns1__ClipExistQueryRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__ClipExistQueryRequest * SOAP_FMAC4 soap_instantiate__ns1__ClipExistQueryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ClipExistQueryRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ClipExistQueryRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__ClipExistQueryRequest;
		if (size)
			*size = sizeof(_ns1__ClipExistQueryRequest);
		((_ns1__ClipExistQueryRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__ClipExistQueryRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ClipExistQueryRequest);
		for (int i = 0; i < n; i++)
			((_ns1__ClipExistQueryRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ClipExistQueryRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ClipExistQueryRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ClipExistQueryRequest %p -> %p\n", q, p));
	*(_ns1__ClipExistQueryRequest*)p = *(_ns1__ClipExistQueryRequest*)q;
}

void _ns1__MaterialQueryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__MaterialQueryRequest::PlanAirDate = NULL;
	this->_ns1__MaterialQueryRequest::ChannelID = NULL;
	this->_ns1__MaterialQueryRequest::ProgramNameKeyWord = NULL;
	/* transient soap skipped */
}

void _ns1__MaterialQueryRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(soap, &this->_ns1__MaterialQueryRequest::PlanAirDate);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__MaterialQueryRequest::ChannelID);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__MaterialQueryRequest::ProgramNameKeyWord);
	/* transient soap skipped */
}

int _ns1__MaterialQueryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__MaterialQueryRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__MaterialQueryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MaterialQueryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MaterialQueryRequest(struct soap *soap, const char *tag, int id, const _ns1__MaterialQueryRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MaterialQueryRequest), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(soap, "ns1:PlanAirDate", -1, &(a->_ns1__MaterialQueryRequest::PlanAirDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ChannelID", -1, &(a->_ns1__MaterialQueryRequest::ChannelID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ProgramNameKeyWord", -1, &(a->_ns1__MaterialQueryRequest::ProgramNameKeyWord), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__MaterialQueryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MaterialQueryRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MaterialQueryRequest * SOAP_FMAC4 soap_get__ns1__MaterialQueryRequest(struct soap *soap, _ns1__MaterialQueryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MaterialQueryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__MaterialQueryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MaterialQueryRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MaterialQueryRequest * SOAP_FMAC4 soap_in__ns1__MaterialQueryRequest(struct soap *soap, const char *tag, _ns1__MaterialQueryRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MaterialQueryRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MaterialQueryRequest, sizeof(_ns1__MaterialQueryRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__MaterialQueryRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__MaterialQueryRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PlanAirDate1 = 1;
	size_t soap_flag_ChannelID1 = 1;
	size_t soap_flag_ProgramNameKeyWord1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PlanAirDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(soap, "ns1:PlanAirDate", &(a->_ns1__MaterialQueryRequest::PlanAirDate), ""))
				{	soap_flag_PlanAirDate1--;
					continue;
				}
			if (soap_flag_ChannelID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:ChannelID", &(a->_ns1__MaterialQueryRequest::ChannelID), "xsd:string"))
				{	soap_flag_ChannelID1--;
					continue;
				}
			if (soap_flag_ProgramNameKeyWord1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:ProgramNameKeyWord", &(a->_ns1__MaterialQueryRequest::ProgramNameKeyWord), "xsd:string"))
				{	soap_flag_ProgramNameKeyWord1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MaterialQueryRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MaterialQueryRequest, 0, sizeof(_ns1__MaterialQueryRequest), 0, soap_copy__ns1__MaterialQueryRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PlanAirDate1 > 0 || soap_flag_ChannelID1 > 0 || soap_flag_ProgramNameKeyWord1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__MaterialQueryRequest * SOAP_FMAC4 soap_instantiate__ns1__MaterialQueryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MaterialQueryRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__MaterialQueryRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__MaterialQueryRequest;
		if (size)
			*size = sizeof(_ns1__MaterialQueryRequest);
		((_ns1__MaterialQueryRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__MaterialQueryRequest[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__MaterialQueryRequest);
		for (int i = 0; i < n; i++)
			((_ns1__MaterialQueryRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__MaterialQueryRequest*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__MaterialQueryRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__MaterialQueryRequest %p -> %p\n", q, p));
	*(_ns1__MaterialQueryRequest*)p = *(_ns1__MaterialQueryRequest*)q;
}

void ns1__ProgramBasicEntityType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ProgramBasicEntityType::ProgramCode = NULL;
	this->ns1__ProgramBasicEntityType::ProgramName = NULL;
	/* transient soap skipped */
}

void ns1__ProgramBasicEntityType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__ProgramBasicEntityType::ProgramCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ProgramBasicEntityType::ProgramName);
	/* transient soap skipped */
}

int ns1__ProgramBasicEntityType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ProgramBasicEntityType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ProgramBasicEntityType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ProgramBasicEntityType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProgramBasicEntityType(struct soap *soap, const char *tag, int id, const ns1__ProgramBasicEntityType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProgramBasicEntityType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ProgramCode", -1, &(a->ns1__ProgramBasicEntityType::ProgramCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ProgramName", -1, &(a->ns1__ProgramBasicEntityType::ProgramName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ProgramBasicEntityType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ProgramBasicEntityType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ProgramBasicEntityType * SOAP_FMAC4 soap_get_ns1__ProgramBasicEntityType(struct soap *soap, ns1__ProgramBasicEntityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProgramBasicEntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ProgramBasicEntityType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ProgramBasicEntityType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ProgramBasicEntityType * SOAP_FMAC4 soap_in_ns1__ProgramBasicEntityType(struct soap *soap, const char *tag, ns1__ProgramBasicEntityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ProgramBasicEntityType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProgramBasicEntityType, sizeof(ns1__ProgramBasicEntityType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ProgramBasicEntityType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ProgramBasicEntityType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ProgramCode1 = 1;
	size_t soap_flag_ProgramName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProgramCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:ProgramCode", &(a->ns1__ProgramBasicEntityType::ProgramCode), "xsd:string"))
				{	soap_flag_ProgramCode1--;
					continue;
				}
			if (soap_flag_ProgramName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:ProgramName", &(a->ns1__ProgramBasicEntityType::ProgramName), "xsd:string"))
				{	soap_flag_ProgramName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ProgramBasicEntityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProgramBasicEntityType, 0, sizeof(ns1__ProgramBasicEntityType), 0, soap_copy_ns1__ProgramBasicEntityType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ProgramBasicEntityType * SOAP_FMAC4 soap_instantiate_ns1__ProgramBasicEntityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ProgramBasicEntityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ProgramBasicEntityType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ProgramBasicEntityType;
		if (size)
			*size = sizeof(ns1__ProgramBasicEntityType);
		((ns1__ProgramBasicEntityType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ProgramBasicEntityType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ProgramBasicEntityType);
		for (int i = 0; i < n; i++)
			((ns1__ProgramBasicEntityType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ProgramBasicEntityType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ProgramBasicEntityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ProgramBasicEntityType %p -> %p\n", q, p));
	*(ns1__ProgramBasicEntityType*)p = *(ns1__ProgramBasicEntityType*)q;
}

void _CLIPSVR__QueryCacheResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_CLIPSVR__QueryCacheResponse::QueryCacheResult = NULL;
	/* transient soap skipped */
}

void _CLIPSVR__QueryCacheResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_CLIPSVR__QueryCacheResponse::QueryCacheResult);
	/* transient soap skipped */
}

int _CLIPSVR__QueryCacheResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__CLIPSVR__QueryCacheResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _CLIPSVR__QueryCacheResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__CLIPSVR__QueryCacheResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__CLIPSVR__QueryCacheResponse(struct soap *soap, const char *tag, int id, const _CLIPSVR__QueryCacheResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__CLIPSVR__QueryCacheResponse), type))
		return soap->error;
	if (a->QueryCacheResult)
		soap_element_result(soap, "CLIPSVR:QueryCacheResult");
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:QueryCacheResult", -1, &(a->_CLIPSVR__QueryCacheResponse::QueryCacheResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_CLIPSVR__QueryCacheResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__CLIPSVR__QueryCacheResponse(soap, this, tag, type);
}

SOAP_FMAC3 _CLIPSVR__QueryCacheResponse * SOAP_FMAC4 soap_get__CLIPSVR__QueryCacheResponse(struct soap *soap, _CLIPSVR__QueryCacheResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__CLIPSVR__QueryCacheResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_CLIPSVR__QueryCacheResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__CLIPSVR__QueryCacheResponse(soap, tag, this, type);
}

SOAP_FMAC3 _CLIPSVR__QueryCacheResponse * SOAP_FMAC4 soap_in__CLIPSVR__QueryCacheResponse(struct soap *soap, const char *tag, _CLIPSVR__QueryCacheResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_CLIPSVR__QueryCacheResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__CLIPSVR__QueryCacheResponse, sizeof(_CLIPSVR__QueryCacheResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__CLIPSVR__QueryCacheResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_CLIPSVR__QueryCacheResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_QueryCacheResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QueryCacheResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:QueryCacheResult", &(a->_CLIPSVR__QueryCacheResponse::QueryCacheResult), "xsd:string"))
				{	soap_flag_QueryCacheResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "CLIPSVR:QueryCacheResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_CLIPSVR__QueryCacheResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__CLIPSVR__QueryCacheResponse, 0, sizeof(_CLIPSVR__QueryCacheResponse), 0, soap_copy__CLIPSVR__QueryCacheResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _CLIPSVR__QueryCacheResponse * SOAP_FMAC4 soap_instantiate__CLIPSVR__QueryCacheResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__CLIPSVR__QueryCacheResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__CLIPSVR__QueryCacheResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _CLIPSVR__QueryCacheResponse;
		if (size)
			*size = sizeof(_CLIPSVR__QueryCacheResponse);
		((_CLIPSVR__QueryCacheResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _CLIPSVR__QueryCacheResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_CLIPSVR__QueryCacheResponse);
		for (int i = 0; i < n; i++)
			((_CLIPSVR__QueryCacheResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_CLIPSVR__QueryCacheResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__CLIPSVR__QueryCacheResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _CLIPSVR__QueryCacheResponse %p -> %p\n", q, p));
	*(_CLIPSVR__QueryCacheResponse*)p = *(_CLIPSVR__QueryCacheResponse*)q;
}

void _CLIPSVR__QueryCache::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_CLIPSVR__QueryCache::paramIn = NULL;
	/* transient soap skipped */
}

void _CLIPSVR__QueryCache::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_CLIPSVR__QueryCache::paramIn);
	/* transient soap skipped */
}

int _CLIPSVR__QueryCache::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__CLIPSVR__QueryCache);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _CLIPSVR__QueryCache::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__CLIPSVR__QueryCache(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__CLIPSVR__QueryCache(struct soap *soap, const char *tag, int id, const _CLIPSVR__QueryCache *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__CLIPSVR__QueryCache), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:paramIn", -1, &(a->_CLIPSVR__QueryCache::paramIn), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_CLIPSVR__QueryCache::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__CLIPSVR__QueryCache(soap, this, tag, type);
}

SOAP_FMAC3 _CLIPSVR__QueryCache * SOAP_FMAC4 soap_get__CLIPSVR__QueryCache(struct soap *soap, _CLIPSVR__QueryCache *p, const char *tag, const char *type)
{
	if ((p = soap_in__CLIPSVR__QueryCache(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_CLIPSVR__QueryCache::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__CLIPSVR__QueryCache(soap, tag, this, type);
}

SOAP_FMAC3 _CLIPSVR__QueryCache * SOAP_FMAC4 soap_in__CLIPSVR__QueryCache(struct soap *soap, const char *tag, _CLIPSVR__QueryCache *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_CLIPSVR__QueryCache *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__CLIPSVR__QueryCache, sizeof(_CLIPSVR__QueryCache), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__CLIPSVR__QueryCache)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_CLIPSVR__QueryCache *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_paramIn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paramIn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:paramIn", &(a->_CLIPSVR__QueryCache::paramIn), "xsd:string"))
				{	soap_flag_paramIn1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_CLIPSVR__QueryCache *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__CLIPSVR__QueryCache, 0, sizeof(_CLIPSVR__QueryCache), 0, soap_copy__CLIPSVR__QueryCache);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _CLIPSVR__QueryCache * SOAP_FMAC4 soap_instantiate__CLIPSVR__QueryCache(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__CLIPSVR__QueryCache(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__CLIPSVR__QueryCache, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _CLIPSVR__QueryCache;
		if (size)
			*size = sizeof(_CLIPSVR__QueryCache);
		((_CLIPSVR__QueryCache*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _CLIPSVR__QueryCache[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_CLIPSVR__QueryCache);
		for (int i = 0; i < n; i++)
			((_CLIPSVR__QueryCache*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_CLIPSVR__QueryCache*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__CLIPSVR__QueryCache(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _CLIPSVR__QueryCache %p -> %p\n", q, p));
	*(_CLIPSVR__QueryCache*)p = *(_CLIPSVR__QueryCache*)q;
}

void _CLIPSVR__ClipIsExistQueryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_CLIPSVR__ClipIsExistQueryResponse::ns1__ClipIsExistQueryResult = NULL;
	/* transient soap skipped */
}

void _CLIPSVR__ClipIsExistQueryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ClipIsExistQueryResult(soap, &this->_CLIPSVR__ClipIsExistQueryResponse::ns1__ClipIsExistQueryResult);
	/* transient soap skipped */
}

int _CLIPSVR__ClipIsExistQueryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _CLIPSVR__ClipIsExistQueryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__CLIPSVR__ClipIsExistQueryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__CLIPSVR__ClipIsExistQueryResponse(struct soap *soap, const char *tag, int id, const _CLIPSVR__ClipIsExistQueryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse), type))
		return soap->error;
	if (a->ns1__ClipIsExistQueryResult)
		soap_element_result(soap, "ns1:ClipIsExistQueryResult");
	if (soap_out_PointerTo_ns1__ClipIsExistQueryResult(soap, "ns1:ClipIsExistQueryResult", -1, &(a->_CLIPSVR__ClipIsExistQueryResponse::ns1__ClipIsExistQueryResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_CLIPSVR__ClipIsExistQueryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__CLIPSVR__ClipIsExistQueryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _CLIPSVR__ClipIsExistQueryResponse * SOAP_FMAC4 soap_get__CLIPSVR__ClipIsExistQueryResponse(struct soap *soap, _CLIPSVR__ClipIsExistQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__CLIPSVR__ClipIsExistQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_CLIPSVR__ClipIsExistQueryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__CLIPSVR__ClipIsExistQueryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _CLIPSVR__ClipIsExistQueryResponse * SOAP_FMAC4 soap_in__CLIPSVR__ClipIsExistQueryResponse(struct soap *soap, const char *tag, _CLIPSVR__ClipIsExistQueryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_CLIPSVR__ClipIsExistQueryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse, sizeof(_CLIPSVR__ClipIsExistQueryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_CLIPSVR__ClipIsExistQueryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns1__ClipIsExistQueryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ClipIsExistQueryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ClipIsExistQueryResult(soap, "ns1:ClipIsExistQueryResult", &(a->_CLIPSVR__ClipIsExistQueryResponse::ns1__ClipIsExistQueryResult), ""))
				{	soap_flag_ns1__ClipIsExistQueryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:ClipIsExistQueryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_CLIPSVR__ClipIsExistQueryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse, 0, sizeof(_CLIPSVR__ClipIsExistQueryResponse), 0, soap_copy__CLIPSVR__ClipIsExistQueryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__ClipIsExistQueryResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _CLIPSVR__ClipIsExistQueryResponse * SOAP_FMAC4 soap_instantiate__CLIPSVR__ClipIsExistQueryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__CLIPSVR__ClipIsExistQueryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _CLIPSVR__ClipIsExistQueryResponse;
		if (size)
			*size = sizeof(_CLIPSVR__ClipIsExistQueryResponse);
		((_CLIPSVR__ClipIsExistQueryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _CLIPSVR__ClipIsExistQueryResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_CLIPSVR__ClipIsExistQueryResponse);
		for (int i = 0; i < n; i++)
			((_CLIPSVR__ClipIsExistQueryResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_CLIPSVR__ClipIsExistQueryResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__CLIPSVR__ClipIsExistQueryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _CLIPSVR__ClipIsExistQueryResponse %p -> %p\n", q, p));
	*(_CLIPSVR__ClipIsExistQueryResponse*)p = *(_CLIPSVR__ClipIsExistQueryResponse*)q;
}

void _CLIPSVR__ClipIsExistQuery::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_CLIPSVR__ClipIsExistQuery::ns1__ClipExistQueryRequest = NULL;
	/* transient soap skipped */
}

void _CLIPSVR__ClipIsExistQuery::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ClipExistQueryRequest(soap, &this->_CLIPSVR__ClipIsExistQuery::ns1__ClipExistQueryRequest);
	/* transient soap skipped */
}

int _CLIPSVR__ClipIsExistQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__CLIPSVR__ClipIsExistQuery);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _CLIPSVR__ClipIsExistQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__CLIPSVR__ClipIsExistQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__CLIPSVR__ClipIsExistQuery(struct soap *soap, const char *tag, int id, const _CLIPSVR__ClipIsExistQuery *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__CLIPSVR__ClipIsExistQuery), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__ClipExistQueryRequest(soap, "ns1:ClipExistQueryRequest", -1, &(a->_CLIPSVR__ClipIsExistQuery::ns1__ClipExistQueryRequest), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_CLIPSVR__ClipIsExistQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__CLIPSVR__ClipIsExistQuery(soap, this, tag, type);
}

SOAP_FMAC3 _CLIPSVR__ClipIsExistQuery * SOAP_FMAC4 soap_get__CLIPSVR__ClipIsExistQuery(struct soap *soap, _CLIPSVR__ClipIsExistQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in__CLIPSVR__ClipIsExistQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_CLIPSVR__ClipIsExistQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__CLIPSVR__ClipIsExistQuery(soap, tag, this, type);
}

SOAP_FMAC3 _CLIPSVR__ClipIsExistQuery * SOAP_FMAC4 soap_in__CLIPSVR__ClipIsExistQuery(struct soap *soap, const char *tag, _CLIPSVR__ClipIsExistQuery *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_CLIPSVR__ClipIsExistQuery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__CLIPSVR__ClipIsExistQuery, sizeof(_CLIPSVR__ClipIsExistQuery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__CLIPSVR__ClipIsExistQuery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_CLIPSVR__ClipIsExistQuery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns1__ClipExistQueryRequest1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ClipExistQueryRequest1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ClipExistQueryRequest(soap, "ns1:ClipExistQueryRequest", &(a->_CLIPSVR__ClipIsExistQuery::ns1__ClipExistQueryRequest), ""))
				{	soap_flag_ns1__ClipExistQueryRequest1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_CLIPSVR__ClipIsExistQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__CLIPSVR__ClipIsExistQuery, 0, sizeof(_CLIPSVR__ClipIsExistQuery), 0, soap_copy__CLIPSVR__ClipIsExistQuery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__ClipExistQueryRequest1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _CLIPSVR__ClipIsExistQuery * SOAP_FMAC4 soap_instantiate__CLIPSVR__ClipIsExistQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__CLIPSVR__ClipIsExistQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__CLIPSVR__ClipIsExistQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _CLIPSVR__ClipIsExistQuery;
		if (size)
			*size = sizeof(_CLIPSVR__ClipIsExistQuery);
		((_CLIPSVR__ClipIsExistQuery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _CLIPSVR__ClipIsExistQuery[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_CLIPSVR__ClipIsExistQuery);
		for (int i = 0; i < n; i++)
			((_CLIPSVR__ClipIsExistQuery*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_CLIPSVR__ClipIsExistQuery*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__CLIPSVR__ClipIsExistQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _CLIPSVR__ClipIsExistQuery %p -> %p\n", q, p));
	*(_CLIPSVR__ClipIsExistQuery*)p = *(_CLIPSVR__ClipIsExistQuery*)q;
}

void _CLIPSVR__MaterialQueryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_CLIPSVR__MaterialQueryResponse::MaterialQueryResult = NULL;
	/* transient soap skipped */
}

void _CLIPSVR__MaterialQueryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(soap, &this->_CLIPSVR__MaterialQueryResponse::MaterialQueryResult);
	/* transient soap skipped */
}

int _CLIPSVR__MaterialQueryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__CLIPSVR__MaterialQueryResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _CLIPSVR__MaterialQueryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__CLIPSVR__MaterialQueryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__CLIPSVR__MaterialQueryResponse(struct soap *soap, const char *tag, int id, const _CLIPSVR__MaterialQueryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__CLIPSVR__MaterialQueryResponse), type))
		return soap->error;
	if (a->MaterialQueryResult)
		soap_element_result(soap, "CLIPSVR:MaterialQueryResult");
	if (soap_out_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(soap, "CLIPSVR:MaterialQueryResult", -1, &(a->_CLIPSVR__MaterialQueryResponse::MaterialQueryResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_CLIPSVR__MaterialQueryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__CLIPSVR__MaterialQueryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _CLIPSVR__MaterialQueryResponse * SOAP_FMAC4 soap_get__CLIPSVR__MaterialQueryResponse(struct soap *soap, _CLIPSVR__MaterialQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__CLIPSVR__MaterialQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_CLIPSVR__MaterialQueryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__CLIPSVR__MaterialQueryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _CLIPSVR__MaterialQueryResponse * SOAP_FMAC4 soap_in__CLIPSVR__MaterialQueryResponse(struct soap *soap, const char *tag, _CLIPSVR__MaterialQueryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_CLIPSVR__MaterialQueryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__CLIPSVR__MaterialQueryResponse, sizeof(_CLIPSVR__MaterialQueryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__CLIPSVR__MaterialQueryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_CLIPSVR__MaterialQueryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_MaterialQueryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaterialQueryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(soap, "CLIPSVR:MaterialQueryResult", &(a->_CLIPSVR__MaterialQueryResponse::MaterialQueryResult), "CLIPSVR:ArrayOfProgramBasicEntityType"))
				{	soap_flag_MaterialQueryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "CLIPSVR:MaterialQueryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_CLIPSVR__MaterialQueryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__CLIPSVR__MaterialQueryResponse, 0, sizeof(_CLIPSVR__MaterialQueryResponse), 0, soap_copy__CLIPSVR__MaterialQueryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _CLIPSVR__MaterialQueryResponse * SOAP_FMAC4 soap_instantiate__CLIPSVR__MaterialQueryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__CLIPSVR__MaterialQueryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__CLIPSVR__MaterialQueryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _CLIPSVR__MaterialQueryResponse;
		if (size)
			*size = sizeof(_CLIPSVR__MaterialQueryResponse);
		((_CLIPSVR__MaterialQueryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _CLIPSVR__MaterialQueryResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_CLIPSVR__MaterialQueryResponse);
		for (int i = 0; i < n; i++)
			((_CLIPSVR__MaterialQueryResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_CLIPSVR__MaterialQueryResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__CLIPSVR__MaterialQueryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _CLIPSVR__MaterialQueryResponse %p -> %p\n", q, p));
	*(_CLIPSVR__MaterialQueryResponse*)p = *(_CLIPSVR__MaterialQueryResponse*)q;
}

void _CLIPSVR__MaterialQuery::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_CLIPSVR__MaterialQuery::ns1__MaterialQueryRequest = NULL;
	/* transient soap skipped */
}

void _CLIPSVR__MaterialQuery::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__MaterialQueryRequest(soap, &this->_CLIPSVR__MaterialQuery::ns1__MaterialQueryRequest);
	/* transient soap skipped */
}

int _CLIPSVR__MaterialQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__CLIPSVR__MaterialQuery);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _CLIPSVR__MaterialQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__CLIPSVR__MaterialQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__CLIPSVR__MaterialQuery(struct soap *soap, const char *tag, int id, const _CLIPSVR__MaterialQuery *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__CLIPSVR__MaterialQuery), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__MaterialQueryRequest(soap, "ns1:MaterialQueryRequest", -1, &(a->_CLIPSVR__MaterialQuery::ns1__MaterialQueryRequest), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_CLIPSVR__MaterialQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__CLIPSVR__MaterialQuery(soap, this, tag, type);
}

SOAP_FMAC3 _CLIPSVR__MaterialQuery * SOAP_FMAC4 soap_get__CLIPSVR__MaterialQuery(struct soap *soap, _CLIPSVR__MaterialQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in__CLIPSVR__MaterialQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_CLIPSVR__MaterialQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__CLIPSVR__MaterialQuery(soap, tag, this, type);
}

SOAP_FMAC3 _CLIPSVR__MaterialQuery * SOAP_FMAC4 soap_in__CLIPSVR__MaterialQuery(struct soap *soap, const char *tag, _CLIPSVR__MaterialQuery *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_CLIPSVR__MaterialQuery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__CLIPSVR__MaterialQuery, sizeof(_CLIPSVR__MaterialQuery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__CLIPSVR__MaterialQuery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_CLIPSVR__MaterialQuery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ns1__MaterialQueryRequest1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MaterialQueryRequest1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__MaterialQueryRequest(soap, "ns1:MaterialQueryRequest", &(a->_CLIPSVR__MaterialQuery::ns1__MaterialQueryRequest), ""))
				{	soap_flag_ns1__MaterialQueryRequest1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_CLIPSVR__MaterialQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__CLIPSVR__MaterialQuery, 0, sizeof(_CLIPSVR__MaterialQuery), 0, soap_copy__CLIPSVR__MaterialQuery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns1__MaterialQueryRequest1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _CLIPSVR__MaterialQuery * SOAP_FMAC4 soap_instantiate__CLIPSVR__MaterialQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__CLIPSVR__MaterialQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__CLIPSVR__MaterialQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _CLIPSVR__MaterialQuery;
		if (size)
			*size = sizeof(_CLIPSVR__MaterialQuery);
		((_CLIPSVR__MaterialQuery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _CLIPSVR__MaterialQuery[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_CLIPSVR__MaterialQuery);
		for (int i = 0; i < n; i++)
			((_CLIPSVR__MaterialQuery*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_CLIPSVR__MaterialQuery*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__CLIPSVR__MaterialQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _CLIPSVR__MaterialQuery %p -> %p\n", q, p));
	*(_CLIPSVR__MaterialQuery*)p = *(_CLIPSVR__MaterialQuery*)q;
}

void _CLIPSVR__TransferTaskExcuteResultNotifyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_CLIPSVR__TransferTaskExcuteResultNotifyResponse::TransferTaskExcuteResultNotifyResult);
	/* transient soap skipped */
}

void _CLIPSVR__TransferTaskExcuteResultNotifyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _CLIPSVR__TransferTaskExcuteResultNotifyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _CLIPSVR__TransferTaskExcuteResultNotifyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__CLIPSVR__TransferTaskExcuteResultNotifyResponse(struct soap *soap, const char *tag, int id, const _CLIPSVR__TransferTaskExcuteResultNotifyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse), type))
		return soap->error;
	soap_element_result(soap, "CLIPSVR:TransferTaskExcuteResultNotifyResult");
	if (soap_out_bool(soap, "CLIPSVR:TransferTaskExcuteResultNotifyResult", -1, &(a->_CLIPSVR__TransferTaskExcuteResultNotifyResponse::TransferTaskExcuteResultNotifyResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_CLIPSVR__TransferTaskExcuteResultNotifyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _CLIPSVR__TransferTaskExcuteResultNotifyResponse * SOAP_FMAC4 soap_get__CLIPSVR__TransferTaskExcuteResultNotifyResponse(struct soap *soap, _CLIPSVR__TransferTaskExcuteResultNotifyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_CLIPSVR__TransferTaskExcuteResultNotifyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _CLIPSVR__TransferTaskExcuteResultNotifyResponse * SOAP_FMAC4 soap_in__CLIPSVR__TransferTaskExcuteResultNotifyResponse(struct soap *soap, const char *tag, _CLIPSVR__TransferTaskExcuteResultNotifyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_CLIPSVR__TransferTaskExcuteResultNotifyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse, sizeof(_CLIPSVR__TransferTaskExcuteResultNotifyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_CLIPSVR__TransferTaskExcuteResultNotifyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TransferTaskExcuteResultNotifyResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TransferTaskExcuteResultNotifyResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "CLIPSVR:TransferTaskExcuteResultNotifyResult", &(a->_CLIPSVR__TransferTaskExcuteResultNotifyResponse::TransferTaskExcuteResultNotifyResult), "xsd:boolean"))
				{	soap_flag_TransferTaskExcuteResultNotifyResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "CLIPSVR:TransferTaskExcuteResultNotifyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_CLIPSVR__TransferTaskExcuteResultNotifyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse, 0, sizeof(_CLIPSVR__TransferTaskExcuteResultNotifyResponse), 0, soap_copy__CLIPSVR__TransferTaskExcuteResultNotifyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TransferTaskExcuteResultNotifyResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _CLIPSVR__TransferTaskExcuteResultNotifyResponse * SOAP_FMAC4 soap_instantiate__CLIPSVR__TransferTaskExcuteResultNotifyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__CLIPSVR__TransferTaskExcuteResultNotifyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _CLIPSVR__TransferTaskExcuteResultNotifyResponse;
		if (size)
			*size = sizeof(_CLIPSVR__TransferTaskExcuteResultNotifyResponse);
		((_CLIPSVR__TransferTaskExcuteResultNotifyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _CLIPSVR__TransferTaskExcuteResultNotifyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_CLIPSVR__TransferTaskExcuteResultNotifyResponse);
		for (int i = 0; i < n; i++)
			((_CLIPSVR__TransferTaskExcuteResultNotifyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_CLIPSVR__TransferTaskExcuteResultNotifyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__CLIPSVR__TransferTaskExcuteResultNotifyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _CLIPSVR__TransferTaskExcuteResultNotifyResponse %p -> %p\n", q, p));
	*(_CLIPSVR__TransferTaskExcuteResultNotifyResponse*)p = *(_CLIPSVR__TransferTaskExcuteResultNotifyResponse*)q;
}

void _CLIPSVR__TransferTaskExcuteResultNotify::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_CLIPSVR__TransferTaskExcuteResultNotify::ResultXML = NULL;
	/* transient soap skipped */
}

void _CLIPSVR__TransferTaskExcuteResultNotify::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_CLIPSVR__TransferTaskExcuteResultNotify::ResultXML);
	/* transient soap skipped */
}

int _CLIPSVR__TransferTaskExcuteResultNotify::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _CLIPSVR__TransferTaskExcuteResultNotify::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__CLIPSVR__TransferTaskExcuteResultNotify(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__CLIPSVR__TransferTaskExcuteResultNotify(struct soap *soap, const char *tag, int id, const _CLIPSVR__TransferTaskExcuteResultNotify *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:ResultXML", -1, &(a->_CLIPSVR__TransferTaskExcuteResultNotify::ResultXML), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_CLIPSVR__TransferTaskExcuteResultNotify::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__CLIPSVR__TransferTaskExcuteResultNotify(soap, this, tag, type);
}

SOAP_FMAC3 _CLIPSVR__TransferTaskExcuteResultNotify * SOAP_FMAC4 soap_get__CLIPSVR__TransferTaskExcuteResultNotify(struct soap *soap, _CLIPSVR__TransferTaskExcuteResultNotify *p, const char *tag, const char *type)
{
	if ((p = soap_in__CLIPSVR__TransferTaskExcuteResultNotify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_CLIPSVR__TransferTaskExcuteResultNotify::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__CLIPSVR__TransferTaskExcuteResultNotify(soap, tag, this, type);
}

SOAP_FMAC3 _CLIPSVR__TransferTaskExcuteResultNotify * SOAP_FMAC4 soap_in__CLIPSVR__TransferTaskExcuteResultNotify(struct soap *soap, const char *tag, _CLIPSVR__TransferTaskExcuteResultNotify *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_CLIPSVR__TransferTaskExcuteResultNotify *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify, sizeof(_CLIPSVR__TransferTaskExcuteResultNotify), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_CLIPSVR__TransferTaskExcuteResultNotify *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ResultXML1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultXML1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:ResultXML", &(a->_CLIPSVR__TransferTaskExcuteResultNotify::ResultXML), "xsd:string"))
				{	soap_flag_ResultXML1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_CLIPSVR__TransferTaskExcuteResultNotify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify, 0, sizeof(_CLIPSVR__TransferTaskExcuteResultNotify), 0, soap_copy__CLIPSVR__TransferTaskExcuteResultNotify);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _CLIPSVR__TransferTaskExcuteResultNotify * SOAP_FMAC4 soap_instantiate__CLIPSVR__TransferTaskExcuteResultNotify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__CLIPSVR__TransferTaskExcuteResultNotify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _CLIPSVR__TransferTaskExcuteResultNotify;
		if (size)
			*size = sizeof(_CLIPSVR__TransferTaskExcuteResultNotify);
		((_CLIPSVR__TransferTaskExcuteResultNotify*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _CLIPSVR__TransferTaskExcuteResultNotify[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_CLIPSVR__TransferTaskExcuteResultNotify);
		for (int i = 0; i < n; i++)
			((_CLIPSVR__TransferTaskExcuteResultNotify*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_CLIPSVR__TransferTaskExcuteResultNotify*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__CLIPSVR__TransferTaskExcuteResultNotify(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _CLIPSVR__TransferTaskExcuteResultNotify %p -> %p\n", q, p));
	*(_CLIPSVR__TransferTaskExcuteResultNotify*)p = *(_CLIPSVR__TransferTaskExcuteResultNotify*)q;
}

void _CLIPSVR__OutStorageFunctionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_CLIPSVR__OutStorageFunctionResponse::OutStorageFunctionResponse = NULL;
	/* transient soap skipped */
}

void _CLIPSVR__OutStorageFunctionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToCLIPSVR__StatusDesc(soap, &this->_CLIPSVR__OutStorageFunctionResponse::OutStorageFunctionResponse);
	/* transient soap skipped */
}

int _CLIPSVR__OutStorageFunctionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _CLIPSVR__OutStorageFunctionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__CLIPSVR__OutStorageFunctionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__CLIPSVR__OutStorageFunctionResponse(struct soap *soap, const char *tag, int id, const _CLIPSVR__OutStorageFunctionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse), type))
		return soap->error;
	if (a->OutStorageFunctionResponse)
		soap_element_result(soap, "CLIPSVR:OutStorageFunctionResponse");
	if (soap_out_PointerToCLIPSVR__StatusDesc(soap, "CLIPSVR:OutStorageFunctionResponse", -1, &(a->_CLIPSVR__OutStorageFunctionResponse::OutStorageFunctionResponse), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_CLIPSVR__OutStorageFunctionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__CLIPSVR__OutStorageFunctionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _CLIPSVR__OutStorageFunctionResponse * SOAP_FMAC4 soap_get__CLIPSVR__OutStorageFunctionResponse(struct soap *soap, _CLIPSVR__OutStorageFunctionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__CLIPSVR__OutStorageFunctionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_CLIPSVR__OutStorageFunctionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__CLIPSVR__OutStorageFunctionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _CLIPSVR__OutStorageFunctionResponse * SOAP_FMAC4 soap_in__CLIPSVR__OutStorageFunctionResponse(struct soap *soap, const char *tag, _CLIPSVR__OutStorageFunctionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_CLIPSVR__OutStorageFunctionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse, sizeof(_CLIPSVR__OutStorageFunctionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_CLIPSVR__OutStorageFunctionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_OutStorageFunctionResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OutStorageFunctionResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToCLIPSVR__StatusDesc(soap, "CLIPSVR:OutStorageFunctionResponse", &(a->_CLIPSVR__OutStorageFunctionResponse::OutStorageFunctionResponse), "CLIPSVR:StatusDesc"))
				{	soap_flag_OutStorageFunctionResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "CLIPSVR:OutStorageFunctionResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_CLIPSVR__OutStorageFunctionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse, 0, sizeof(_CLIPSVR__OutStorageFunctionResponse), 0, soap_copy__CLIPSVR__OutStorageFunctionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _CLIPSVR__OutStorageFunctionResponse * SOAP_FMAC4 soap_instantiate__CLIPSVR__OutStorageFunctionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__CLIPSVR__OutStorageFunctionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _CLIPSVR__OutStorageFunctionResponse;
		if (size)
			*size = sizeof(_CLIPSVR__OutStorageFunctionResponse);
		((_CLIPSVR__OutStorageFunctionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _CLIPSVR__OutStorageFunctionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_CLIPSVR__OutStorageFunctionResponse);
		for (int i = 0; i < n; i++)
			((_CLIPSVR__OutStorageFunctionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_CLIPSVR__OutStorageFunctionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__CLIPSVR__OutStorageFunctionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _CLIPSVR__OutStorageFunctionResponse %p -> %p\n", q, p));
	*(_CLIPSVR__OutStorageFunctionResponse*)p = *(_CLIPSVR__OutStorageFunctionResponse*)q;
}

void _CLIPSVR__OutStorageFunction::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_CLIPSVR__OutStorageFunction::massageparam = NULL;
	/* transient soap skipped */
}

void _CLIPSVR__OutStorageFunction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToCLIPSVR__OutMessage(soap, &this->_CLIPSVR__OutStorageFunction::massageparam);
	/* transient soap skipped */
}

int _CLIPSVR__OutStorageFunction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__CLIPSVR__OutStorageFunction);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _CLIPSVR__OutStorageFunction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__CLIPSVR__OutStorageFunction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__CLIPSVR__OutStorageFunction(struct soap *soap, const char *tag, int id, const _CLIPSVR__OutStorageFunction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__CLIPSVR__OutStorageFunction), type))
		return soap->error;
	if (soap_out_PointerToCLIPSVR__OutMessage(soap, "CLIPSVR:massageparam", -1, &(a->_CLIPSVR__OutStorageFunction::massageparam), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_CLIPSVR__OutStorageFunction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__CLIPSVR__OutStorageFunction(soap, this, tag, type);
}

SOAP_FMAC3 _CLIPSVR__OutStorageFunction * SOAP_FMAC4 soap_get__CLIPSVR__OutStorageFunction(struct soap *soap, _CLIPSVR__OutStorageFunction *p, const char *tag, const char *type)
{
	if ((p = soap_in__CLIPSVR__OutStorageFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_CLIPSVR__OutStorageFunction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__CLIPSVR__OutStorageFunction(soap, tag, this, type);
}

SOAP_FMAC3 _CLIPSVR__OutStorageFunction * SOAP_FMAC4 soap_in__CLIPSVR__OutStorageFunction(struct soap *soap, const char *tag, _CLIPSVR__OutStorageFunction *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_CLIPSVR__OutStorageFunction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__CLIPSVR__OutStorageFunction, sizeof(_CLIPSVR__OutStorageFunction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__CLIPSVR__OutStorageFunction)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_CLIPSVR__OutStorageFunction *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_massageparam1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_massageparam1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToCLIPSVR__OutMessage(soap, "CLIPSVR:massageparam", &(a->_CLIPSVR__OutStorageFunction::massageparam), "CLIPSVR:OutMessage"))
				{	soap_flag_massageparam1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_CLIPSVR__OutStorageFunction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__CLIPSVR__OutStorageFunction, 0, sizeof(_CLIPSVR__OutStorageFunction), 0, soap_copy__CLIPSVR__OutStorageFunction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _CLIPSVR__OutStorageFunction * SOAP_FMAC4 soap_instantiate__CLIPSVR__OutStorageFunction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__CLIPSVR__OutStorageFunction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__CLIPSVR__OutStorageFunction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _CLIPSVR__OutStorageFunction;
		if (size)
			*size = sizeof(_CLIPSVR__OutStorageFunction);
		((_CLIPSVR__OutStorageFunction*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _CLIPSVR__OutStorageFunction[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_CLIPSVR__OutStorageFunction);
		for (int i = 0; i < n; i++)
			((_CLIPSVR__OutStorageFunction*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_CLIPSVR__OutStorageFunction*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__CLIPSVR__OutStorageFunction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _CLIPSVR__OutStorageFunction %p -> %p\n", q, p));
	*(_CLIPSVR__OutStorageFunction*)p = *(_CLIPSVR__OutStorageFunction*)q;
}

void CLIPSVR__ArrayOfProgramBasicEntityType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(soap, &this->CLIPSVR__ArrayOfProgramBasicEntityType::ProgramBasicEntityType);
	/* transient soap skipped */
}

void CLIPSVR__ArrayOfProgramBasicEntityType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(soap, &this->CLIPSVR__ArrayOfProgramBasicEntityType::ProgramBasicEntityType);
	/* transient soap skipped */
}

int CLIPSVR__ArrayOfProgramBasicEntityType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int CLIPSVR__ArrayOfProgramBasicEntityType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_CLIPSVR__ArrayOfProgramBasicEntityType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CLIPSVR__ArrayOfProgramBasicEntityType(struct soap *soap, const char *tag, int id, const CLIPSVR__ArrayOfProgramBasicEntityType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(soap, "CLIPSVR:ProgramBasicEntityType", -1, &(a->CLIPSVR__ArrayOfProgramBasicEntityType::ProgramBasicEntityType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *CLIPSVR__ArrayOfProgramBasicEntityType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_CLIPSVR__ArrayOfProgramBasicEntityType(soap, this, tag, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfProgramBasicEntityType * SOAP_FMAC4 soap_get_CLIPSVR__ArrayOfProgramBasicEntityType(struct soap *soap, CLIPSVR__ArrayOfProgramBasicEntityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_CLIPSVR__ArrayOfProgramBasicEntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *CLIPSVR__ArrayOfProgramBasicEntityType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_CLIPSVR__ArrayOfProgramBasicEntityType(soap, tag, this, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfProgramBasicEntityType * SOAP_FMAC4 soap_in_CLIPSVR__ArrayOfProgramBasicEntityType(struct soap *soap, const char *tag, CLIPSVR__ArrayOfProgramBasicEntityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (CLIPSVR__ArrayOfProgramBasicEntityType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType, sizeof(CLIPSVR__ArrayOfProgramBasicEntityType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (CLIPSVR__ArrayOfProgramBasicEntityType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(soap, "CLIPSVR:ProgramBasicEntityType", &(a->CLIPSVR__ArrayOfProgramBasicEntityType::ProgramBasicEntityType), "ns1:ProgramBasicEntityType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (CLIPSVR__ArrayOfProgramBasicEntityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType, 0, sizeof(CLIPSVR__ArrayOfProgramBasicEntityType), 0, soap_copy_CLIPSVR__ArrayOfProgramBasicEntityType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 CLIPSVR__ArrayOfProgramBasicEntityType * SOAP_FMAC4 soap_instantiate_CLIPSVR__ArrayOfProgramBasicEntityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CLIPSVR__ArrayOfProgramBasicEntityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new CLIPSVR__ArrayOfProgramBasicEntityType;
		if (size)
			*size = sizeof(CLIPSVR__ArrayOfProgramBasicEntityType);
		((CLIPSVR__ArrayOfProgramBasicEntityType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new CLIPSVR__ArrayOfProgramBasicEntityType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(CLIPSVR__ArrayOfProgramBasicEntityType);
		for (int i = 0; i < n; i++)
			((CLIPSVR__ArrayOfProgramBasicEntityType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (CLIPSVR__ArrayOfProgramBasicEntityType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_CLIPSVR__ArrayOfProgramBasicEntityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying CLIPSVR__ArrayOfProgramBasicEntityType %p -> %p\n", q, p));
	*(CLIPSVR__ArrayOfProgramBasicEntityType*)p = *(CLIPSVR__ArrayOfProgramBasicEntityType*)q;
}

void CLIPSVR__StatusDesc::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->CLIPSVR__StatusDesc::code = NULL;
	this->CLIPSVR__StatusDesc::desc = NULL;
	soap_default_int(soap, &this->CLIPSVR__StatusDesc::retry);
	/* transient soap skipped */
}

void CLIPSVR__StatusDesc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__StatusDesc::code);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__StatusDesc::desc);
	soap_embedded(soap, &this->CLIPSVR__StatusDesc::retry, SOAP_TYPE_int);
	/* transient soap skipped */
}

int CLIPSVR__StatusDesc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_CLIPSVR__StatusDesc);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int CLIPSVR__StatusDesc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_CLIPSVR__StatusDesc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CLIPSVR__StatusDesc(struct soap *soap, const char *tag, int id, const CLIPSVR__StatusDesc *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_CLIPSVR__StatusDesc), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:code", -1, &(a->CLIPSVR__StatusDesc::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:desc", -1, &(a->CLIPSVR__StatusDesc::desc), ""))
		return soap->error;
	if (soap_out_int(soap, "CLIPSVR:retry", -1, &(a->CLIPSVR__StatusDesc::retry), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *CLIPSVR__StatusDesc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_CLIPSVR__StatusDesc(soap, this, tag, type);
}

SOAP_FMAC3 CLIPSVR__StatusDesc * SOAP_FMAC4 soap_get_CLIPSVR__StatusDesc(struct soap *soap, CLIPSVR__StatusDesc *p, const char *tag, const char *type)
{
	if ((p = soap_in_CLIPSVR__StatusDesc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *CLIPSVR__StatusDesc::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_CLIPSVR__StatusDesc(soap, tag, this, type);
}

SOAP_FMAC3 CLIPSVR__StatusDesc * SOAP_FMAC4 soap_in_CLIPSVR__StatusDesc(struct soap *soap, const char *tag, CLIPSVR__StatusDesc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (CLIPSVR__StatusDesc *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_CLIPSVR__StatusDesc, sizeof(CLIPSVR__StatusDesc), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_CLIPSVR__StatusDesc)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (CLIPSVR__StatusDesc *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code1 = 1;
	size_t soap_flag_desc1 = 1;
	size_t soap_flag_retry1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:code", &(a->CLIPSVR__StatusDesc::code), "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:desc", &(a->CLIPSVR__StatusDesc::desc), "xsd:string"))
				{	soap_flag_desc1--;
					continue;
				}
			if (soap_flag_retry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CLIPSVR:retry", &(a->CLIPSVR__StatusDesc::retry), "xsd:int"))
				{	soap_flag_retry1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (CLIPSVR__StatusDesc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CLIPSVR__StatusDesc, 0, sizeof(CLIPSVR__StatusDesc), 0, soap_copy_CLIPSVR__StatusDesc);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_retry1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 CLIPSVR__StatusDesc * SOAP_FMAC4 soap_instantiate_CLIPSVR__StatusDesc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CLIPSVR__StatusDesc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_CLIPSVR__StatusDesc, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new CLIPSVR__StatusDesc;
		if (size)
			*size = sizeof(CLIPSVR__StatusDesc);
		((CLIPSVR__StatusDesc*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new CLIPSVR__StatusDesc[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(CLIPSVR__StatusDesc);
		for (int i = 0; i < n; i++)
			((CLIPSVR__StatusDesc*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (CLIPSVR__StatusDesc*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_CLIPSVR__StatusDesc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying CLIPSVR__StatusDesc %p -> %p\n", q, p));
	*(CLIPSVR__StatusDesc*)p = *(CLIPSVR__StatusDesc*)q;
}

void CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::__sizeExtentionAttribute = 0;
	this->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute = NULL;
	/* transient soap skipped */
}

void CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute)
	{	int i;
		for (i = 0; i < this->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::__sizeExtentionAttribute; i++)
		{
			soap_embedded(soap, this->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute + i, SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute);
			this->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(struct soap *soap, const char *tag, int id, const CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute), type))
		return soap->error;
	if (a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute)
	{	int i;
		for (i = 0; i < a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::__sizeExtentionAttribute; i++)
			if (a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute[i].soap_out(soap, "CLIPSVR:ExtentionAttribute", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, this, tag, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute * SOAP_FMAC4 soap_get_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(struct soap *soap, CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, tag, this, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute * SOAP_FMAC4 soap_in_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(struct soap *soap, const char *tag, CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute, sizeof(CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ExtentionAttribute1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "CLIPSVR:ExtentionAttribute", 1, NULL))
			{	if (a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute == NULL)
				{	if (soap_blist_ExtentionAttribute1 == NULL)
						soap_blist_ExtentionAttribute1 = soap_new_block(soap);
					a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute = (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *)soap_push_block(soap, soap_blist_ExtentionAttribute1, sizeof(_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute));
					if (a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute == NULL)
						return NULL;
					_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute p;
					memcpy(a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute, &p, sizeof(_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute)); // a bit rough but portable
					a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute->soap_default(soap);
				}soap_revert(soap);
				if (soap_in__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, "CLIPSVR:ExtentionAttribute", a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute, ""))
				{	a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::__sizeExtentionAttribute++;
					a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute)
			soap_pop_block(soap, soap_blist_ExtentionAttribute1);
		if (a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::__sizeExtentionAttribute)
			a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute = (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *)soap_save_block(soap, soap_blist_ExtentionAttribute1, NULL, 1);
		else
		{	a->CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute::ExtentionAttribute = NULL;
			if (soap_blist_ExtentionAttribute1)
				soap_end_block(soap, soap_blist_ExtentionAttribute1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute, 0, sizeof(CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute), 0, soap_copy_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute * SOAP_FMAC4 soap_instantiate_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute;
		if (size)
			*size = sizeof(CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute);
		((CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute);
		for (int i = 0; i < n; i++)
			((CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute %p -> %p\n", q, p));
	*(CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute*)p = *(CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute*)q;
}

void CLIPSVR__BreakPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->CLIPSVR__BreakPoint::PointLocation = NULL;
	this->CLIPSVR__BreakPoint::Description = NULL;
	/* transient soap skipped */
}

void CLIPSVR__BreakPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->CLIPSVR__BreakPoint::PointLocation);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__BreakPoint::Description);
	/* transient soap skipped */
}

int CLIPSVR__BreakPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_CLIPSVR__BreakPoint);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int CLIPSVR__BreakPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_CLIPSVR__BreakPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CLIPSVR__BreakPoint(struct soap *soap, const char *tag, int id, const CLIPSVR__BreakPoint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_CLIPSVR__BreakPoint), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "CLIPSVR:PointLocation", -1, &(a->CLIPSVR__BreakPoint::PointLocation), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:Description", -1, &(a->CLIPSVR__BreakPoint::Description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *CLIPSVR__BreakPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_CLIPSVR__BreakPoint(soap, this, tag, type);
}

SOAP_FMAC3 CLIPSVR__BreakPoint * SOAP_FMAC4 soap_get_CLIPSVR__BreakPoint(struct soap *soap, CLIPSVR__BreakPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_CLIPSVR__BreakPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *CLIPSVR__BreakPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_CLIPSVR__BreakPoint(soap, tag, this, type);
}

SOAP_FMAC3 CLIPSVR__BreakPoint * SOAP_FMAC4 soap_in_CLIPSVR__BreakPoint(struct soap *soap, const char *tag, CLIPSVR__BreakPoint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (CLIPSVR__BreakPoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_CLIPSVR__BreakPoint, sizeof(CLIPSVR__BreakPoint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_CLIPSVR__BreakPoint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (CLIPSVR__BreakPoint *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PointLocation1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PointLocation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "CLIPSVR:PointLocation", &(a->CLIPSVR__BreakPoint::PointLocation), "xsd:int"))
				{	soap_flag_PointLocation1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:Description", &(a->CLIPSVR__BreakPoint::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (CLIPSVR__BreakPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CLIPSVR__BreakPoint, 0, sizeof(CLIPSVR__BreakPoint), 0, soap_copy_CLIPSVR__BreakPoint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 CLIPSVR__BreakPoint * SOAP_FMAC4 soap_instantiate_CLIPSVR__BreakPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CLIPSVR__BreakPoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_CLIPSVR__BreakPoint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new CLIPSVR__BreakPoint;
		if (size)
			*size = sizeof(CLIPSVR__BreakPoint);
		((CLIPSVR__BreakPoint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new CLIPSVR__BreakPoint[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(CLIPSVR__BreakPoint);
		for (int i = 0; i < n; i++)
			((CLIPSVR__BreakPoint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (CLIPSVR__BreakPoint*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_CLIPSVR__BreakPoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying CLIPSVR__BreakPoint %p -> %p\n", q, p));
	*(CLIPSVR__BreakPoint*)p = *(CLIPSVR__BreakPoint*)q;
}

void CLIPSVR__ArrayOfBreakPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(soap, &this->CLIPSVR__ArrayOfBreakPoint::BreakPoints);
	/* transient soap skipped */
}

void CLIPSVR__ArrayOfBreakPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(soap, &this->CLIPSVR__ArrayOfBreakPoint::BreakPoints);
	/* transient soap skipped */
}

int CLIPSVR__ArrayOfBreakPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int CLIPSVR__ArrayOfBreakPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_CLIPSVR__ArrayOfBreakPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CLIPSVR__ArrayOfBreakPoint(struct soap *soap, const char *tag, int id, const CLIPSVR__ArrayOfBreakPoint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(soap, "CLIPSVR:BreakPoints", -1, &(a->CLIPSVR__ArrayOfBreakPoint::BreakPoints), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *CLIPSVR__ArrayOfBreakPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_CLIPSVR__ArrayOfBreakPoint(soap, this, tag, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfBreakPoint * SOAP_FMAC4 soap_get_CLIPSVR__ArrayOfBreakPoint(struct soap *soap, CLIPSVR__ArrayOfBreakPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_CLIPSVR__ArrayOfBreakPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *CLIPSVR__ArrayOfBreakPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_CLIPSVR__ArrayOfBreakPoint(soap, tag, this, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfBreakPoint * SOAP_FMAC4 soap_in_CLIPSVR__ArrayOfBreakPoint(struct soap *soap, const char *tag, CLIPSVR__ArrayOfBreakPoint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (CLIPSVR__ArrayOfBreakPoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint, sizeof(CLIPSVR__ArrayOfBreakPoint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (CLIPSVR__ArrayOfBreakPoint *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(soap, "CLIPSVR:BreakPoints", &(a->CLIPSVR__ArrayOfBreakPoint::BreakPoints), "CLIPSVR:BreakPoint"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (CLIPSVR__ArrayOfBreakPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint, 0, sizeof(CLIPSVR__ArrayOfBreakPoint), 0, soap_copy_CLIPSVR__ArrayOfBreakPoint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 CLIPSVR__ArrayOfBreakPoint * SOAP_FMAC4 soap_instantiate_CLIPSVR__ArrayOfBreakPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CLIPSVR__ArrayOfBreakPoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new CLIPSVR__ArrayOfBreakPoint;
		if (size)
			*size = sizeof(CLIPSVR__ArrayOfBreakPoint);
		((CLIPSVR__ArrayOfBreakPoint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new CLIPSVR__ArrayOfBreakPoint[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(CLIPSVR__ArrayOfBreakPoint);
		for (int i = 0; i < n; i++)
			((CLIPSVR__ArrayOfBreakPoint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (CLIPSVR__ArrayOfBreakPoint*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_CLIPSVR__ArrayOfBreakPoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying CLIPSVR__ArrayOfBreakPoint %p -> %p\n", q, p));
	*(CLIPSVR__ArrayOfBreakPoint*)p = *(CLIPSVR__ArrayOfBreakPoint*)q;
}

void CLIPSVR__OutMessageFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->CLIPSVR__OutMessageFile::md5 = NULL;
	this->CLIPSVR__OutMessageFile::name = NULL;
	/* transient soap skipped */
}

void CLIPSVR__OutMessageFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessageFile::md5);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessageFile::name);
	/* transient soap skipped */
}

int CLIPSVR__OutMessageFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_CLIPSVR__OutMessageFile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int CLIPSVR__OutMessageFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_CLIPSVR__OutMessageFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CLIPSVR__OutMessageFile(struct soap *soap, const char *tag, int id, const CLIPSVR__OutMessageFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_CLIPSVR__OutMessageFile), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:md5", -1, &(a->CLIPSVR__OutMessageFile::md5), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:name", -1, &(a->CLIPSVR__OutMessageFile::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *CLIPSVR__OutMessageFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_CLIPSVR__OutMessageFile(soap, this, tag, type);
}

SOAP_FMAC3 CLIPSVR__OutMessageFile * SOAP_FMAC4 soap_get_CLIPSVR__OutMessageFile(struct soap *soap, CLIPSVR__OutMessageFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_CLIPSVR__OutMessageFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *CLIPSVR__OutMessageFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_CLIPSVR__OutMessageFile(soap, tag, this, type);
}

SOAP_FMAC3 CLIPSVR__OutMessageFile * SOAP_FMAC4 soap_in_CLIPSVR__OutMessageFile(struct soap *soap, const char *tag, CLIPSVR__OutMessageFile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (CLIPSVR__OutMessageFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_CLIPSVR__OutMessageFile, sizeof(CLIPSVR__OutMessageFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_CLIPSVR__OutMessageFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (CLIPSVR__OutMessageFile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_md51 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_md51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:md5", &(a->CLIPSVR__OutMessageFile::md5), "xsd:string"))
				{	soap_flag_md51--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:name", &(a->CLIPSVR__OutMessageFile::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (CLIPSVR__OutMessageFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CLIPSVR__OutMessageFile, 0, sizeof(CLIPSVR__OutMessageFile), 0, soap_copy_CLIPSVR__OutMessageFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 CLIPSVR__OutMessageFile * SOAP_FMAC4 soap_instantiate_CLIPSVR__OutMessageFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CLIPSVR__OutMessageFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_CLIPSVR__OutMessageFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new CLIPSVR__OutMessageFile;
		if (size)
			*size = sizeof(CLIPSVR__OutMessageFile);
		((CLIPSVR__OutMessageFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new CLIPSVR__OutMessageFile[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(CLIPSVR__OutMessageFile);
		for (int i = 0; i < n; i++)
			((CLIPSVR__OutMessageFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (CLIPSVR__OutMessageFile*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_CLIPSVR__OutMessageFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying CLIPSVR__OutMessageFile %p -> %p\n", q, p));
	*(CLIPSVR__OutMessageFile*)p = *(CLIPSVR__OutMessageFile*)q;
}

void CLIPSVR__ArrayOfOutMessageFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(soap, &this->CLIPSVR__ArrayOfOutMessageFile::OutMessageFile);
	/* transient soap skipped */
}

void CLIPSVR__ArrayOfOutMessageFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(soap, &this->CLIPSVR__ArrayOfOutMessageFile::OutMessageFile);
	/* transient soap skipped */
}

int CLIPSVR__ArrayOfOutMessageFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int CLIPSVR__ArrayOfOutMessageFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_CLIPSVR__ArrayOfOutMessageFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CLIPSVR__ArrayOfOutMessageFile(struct soap *soap, const char *tag, int id, const CLIPSVR__ArrayOfOutMessageFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(soap, "CLIPSVR:OutMessageFile", -1, &(a->CLIPSVR__ArrayOfOutMessageFile::OutMessageFile), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *CLIPSVR__ArrayOfOutMessageFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_CLIPSVR__ArrayOfOutMessageFile(soap, this, tag, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfOutMessageFile * SOAP_FMAC4 soap_get_CLIPSVR__ArrayOfOutMessageFile(struct soap *soap, CLIPSVR__ArrayOfOutMessageFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_CLIPSVR__ArrayOfOutMessageFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *CLIPSVR__ArrayOfOutMessageFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_CLIPSVR__ArrayOfOutMessageFile(soap, tag, this, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfOutMessageFile * SOAP_FMAC4 soap_in_CLIPSVR__ArrayOfOutMessageFile(struct soap *soap, const char *tag, CLIPSVR__ArrayOfOutMessageFile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (CLIPSVR__ArrayOfOutMessageFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile, sizeof(CLIPSVR__ArrayOfOutMessageFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (CLIPSVR__ArrayOfOutMessageFile *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(soap, "CLIPSVR:OutMessageFile", &(a->CLIPSVR__ArrayOfOutMessageFile::OutMessageFile), "CLIPSVR:OutMessageFile"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (CLIPSVR__ArrayOfOutMessageFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile, 0, sizeof(CLIPSVR__ArrayOfOutMessageFile), 0, soap_copy_CLIPSVR__ArrayOfOutMessageFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 CLIPSVR__ArrayOfOutMessageFile * SOAP_FMAC4 soap_instantiate_CLIPSVR__ArrayOfOutMessageFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CLIPSVR__ArrayOfOutMessageFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new CLIPSVR__ArrayOfOutMessageFile;
		if (size)
			*size = sizeof(CLIPSVR__ArrayOfOutMessageFile);
		((CLIPSVR__ArrayOfOutMessageFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new CLIPSVR__ArrayOfOutMessageFile[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(CLIPSVR__ArrayOfOutMessageFile);
		for (int i = 0; i < n; i++)
			((CLIPSVR__ArrayOfOutMessageFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (CLIPSVR__ArrayOfOutMessageFile*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_CLIPSVR__ArrayOfOutMessageFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying CLIPSVR__ArrayOfOutMessageFile %p -> %p\n", q, p));
	*(CLIPSVR__ArrayOfOutMessageFile*)p = *(CLIPSVR__ArrayOfOutMessageFile*)q;
}

void CLIPSVR__OutMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->CLIPSVR__OutMessage::programID = NULL;
	this->CLIPSVR__OutMessage::programName = NULL;
	this->CLIPSVR__OutMessage::playDate = NULL;
	this->CLIPSVR__OutMessage::channelId = NULL;
	this->CLIPSVR__OutMessage::clipType = NULL;
	this->CLIPSVR__OutMessage::HD = NULL;
	this->CLIPSVR__OutMessage::startpoint = NULL;
	this->CLIPSVR__OutMessage::endpoint = NULL;
	this->CLIPSVR__OutMessage::length = NULL;
	this->CLIPSVR__OutMessage::fileList = NULL;
	this->CLIPSVR__OutMessage::ip = NULL;
	this->CLIPSVR__OutMessage::path = NULL;
	soap_default_int(soap, &this->CLIPSVR__OutMessage::port);
	this->CLIPSVR__OutMessage::user = NULL;
	this->CLIPSVR__OutMessage::pass = NULL;
	this->CLIPSVR__OutMessage::callbackurl = NULL;
	this->CLIPSVR__OutMessage::emerg = NULL;
	this->CLIPSVR__OutMessage::SourceID = NULL;
	this->CLIPSVR__OutMessage::BreakPointList = NULL;
	this->CLIPSVR__OutMessage::ExtendAttributes = NULL;
	/* transient soap skipped */
}

void CLIPSVR__OutMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessage::programID);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessage::programName);
	soap_serialize_PointerTotime(soap, &this->CLIPSVR__OutMessage::playDate);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessage::channelId);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessage::clipType);
	soap_serialize_PointerToint(soap, &this->CLIPSVR__OutMessage::HD);
	soap_serialize_PointerToint(soap, &this->CLIPSVR__OutMessage::startpoint);
	soap_serialize_PointerToint(soap, &this->CLIPSVR__OutMessage::endpoint);
	soap_serialize_PointerToint(soap, &this->CLIPSVR__OutMessage::length);
	soap_serialize_PointerToCLIPSVR__ArrayOfOutMessageFile(soap, &this->CLIPSVR__OutMessage::fileList);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessage::ip);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessage::path);
	soap_embedded(soap, &this->CLIPSVR__OutMessage::port, SOAP_TYPE_int);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessage::user);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessage::pass);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessage::callbackurl);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessage::emerg);
	soap_serialize_PointerTostd__string(soap, &this->CLIPSVR__OutMessage::SourceID);
	soap_serialize_PointerToCLIPSVR__ArrayOfBreakPoint(soap, &this->CLIPSVR__OutMessage::BreakPointList);
	soap_serialize_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, &this->CLIPSVR__OutMessage::ExtendAttributes);
	/* transient soap skipped */
}

int CLIPSVR__OutMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_CLIPSVR__OutMessage);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int CLIPSVR__OutMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_CLIPSVR__OutMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CLIPSVR__OutMessage(struct soap *soap, const char *tag, int id, const CLIPSVR__OutMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_CLIPSVR__OutMessage), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:programID", -1, &(a->CLIPSVR__OutMessage::programID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:programName", -1, &(a->CLIPSVR__OutMessage::programName), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "CLIPSVR:playDate", -1, &(a->CLIPSVR__OutMessage::playDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:channelId", -1, &(a->CLIPSVR__OutMessage::channelId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:clipType", -1, &(a->CLIPSVR__OutMessage::clipType), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "CLIPSVR:HD", -1, &(a->CLIPSVR__OutMessage::HD), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "CLIPSVR:startpoint", -1, &(a->CLIPSVR__OutMessage::startpoint), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "CLIPSVR:endpoint", -1, &(a->CLIPSVR__OutMessage::endpoint), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "CLIPSVR:length", -1, &(a->CLIPSVR__OutMessage::length), ""))
		return soap->error;
	if (soap_out_PointerToCLIPSVR__ArrayOfOutMessageFile(soap, "CLIPSVR:fileList", -1, &(a->CLIPSVR__OutMessage::fileList), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:ip", -1, &(a->CLIPSVR__OutMessage::ip), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:path", -1, &(a->CLIPSVR__OutMessage::path), ""))
		return soap->error;
	if (soap_out_int(soap, "CLIPSVR:port", -1, &(a->CLIPSVR__OutMessage::port), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:user", -1, &(a->CLIPSVR__OutMessage::user), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:pass", -1, &(a->CLIPSVR__OutMessage::pass), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:callbackurl", -1, &(a->CLIPSVR__OutMessage::callbackurl), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:emerg", -1, &(a->CLIPSVR__OutMessage::emerg), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "CLIPSVR:SourceID", -1, &(a->CLIPSVR__OutMessage::SourceID), ""))
		return soap->error;
	if (soap_out_PointerToCLIPSVR__ArrayOfBreakPoint(soap, "CLIPSVR:BreakPointList", -1, &(a->CLIPSVR__OutMessage::BreakPointList), ""))
		return soap->error;
	if (soap_out_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, "CLIPSVR:ExtendAttributes", -1, &(a->CLIPSVR__OutMessage::ExtendAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *CLIPSVR__OutMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_CLIPSVR__OutMessage(soap, this, tag, type);
}

SOAP_FMAC3 CLIPSVR__OutMessage * SOAP_FMAC4 soap_get_CLIPSVR__OutMessage(struct soap *soap, CLIPSVR__OutMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_CLIPSVR__OutMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *CLIPSVR__OutMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_CLIPSVR__OutMessage(soap, tag, this, type);
}

SOAP_FMAC3 CLIPSVR__OutMessage * SOAP_FMAC4 soap_in_CLIPSVR__OutMessage(struct soap *soap, const char *tag, CLIPSVR__OutMessage *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (CLIPSVR__OutMessage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_CLIPSVR__OutMessage, sizeof(CLIPSVR__OutMessage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_CLIPSVR__OutMessage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (CLIPSVR__OutMessage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_programID1 = 1;
	size_t soap_flag_programName1 = 1;
	size_t soap_flag_playDate1 = 1;
	size_t soap_flag_channelId1 = 1;
	size_t soap_flag_clipType1 = 1;
	size_t soap_flag_HD1 = 1;
	size_t soap_flag_startpoint1 = 1;
	size_t soap_flag_endpoint1 = 1;
	size_t soap_flag_length1 = 1;
	size_t soap_flag_fileList1 = 1;
	size_t soap_flag_ip1 = 1;
	size_t soap_flag_path1 = 1;
	size_t soap_flag_port1 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_pass1 = 1;
	size_t soap_flag_callbackurl1 = 1;
	size_t soap_flag_emerg1 = 1;
	size_t soap_flag_SourceID1 = 1;
	size_t soap_flag_BreakPointList1 = 1;
	size_t soap_flag_ExtendAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_programID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:programID", &(a->CLIPSVR__OutMessage::programID), "xsd:string"))
				{	soap_flag_programID1--;
					continue;
				}
			if (soap_flag_programName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:programName", &(a->CLIPSVR__OutMessage::programName), "xsd:string"))
				{	soap_flag_programName1--;
					continue;
				}
			if (soap_flag_playDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "CLIPSVR:playDate", &(a->CLIPSVR__OutMessage::playDate), "xsd:dateTime"))
				{	soap_flag_playDate1--;
					continue;
				}
			if (soap_flag_channelId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:channelId", &(a->CLIPSVR__OutMessage::channelId), "xsd:string"))
				{	soap_flag_channelId1--;
					continue;
				}
			if (soap_flag_clipType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:clipType", &(a->CLIPSVR__OutMessage::clipType), "xsd:string"))
				{	soap_flag_clipType1--;
					continue;
				}
			if (soap_flag_HD1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "CLIPSVR:HD", &(a->CLIPSVR__OutMessage::HD), "xsd:int"))
				{	soap_flag_HD1--;
					continue;
				}
			if (soap_flag_startpoint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "CLIPSVR:startpoint", &(a->CLIPSVR__OutMessage::startpoint), "xsd:int"))
				{	soap_flag_startpoint1--;
					continue;
				}
			if (soap_flag_endpoint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "CLIPSVR:endpoint", &(a->CLIPSVR__OutMessage::endpoint), "xsd:int"))
				{	soap_flag_endpoint1--;
					continue;
				}
			if (soap_flag_length1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "CLIPSVR:length", &(a->CLIPSVR__OutMessage::length), "xsd:int"))
				{	soap_flag_length1--;
					continue;
				}
			if (soap_flag_fileList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToCLIPSVR__ArrayOfOutMessageFile(soap, "CLIPSVR:fileList", &(a->CLIPSVR__OutMessage::fileList), "CLIPSVR:ArrayOfOutMessageFile"))
				{	soap_flag_fileList1--;
					continue;
				}
			if (soap_flag_ip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:ip", &(a->CLIPSVR__OutMessage::ip), "xsd:string"))
				{	soap_flag_ip1--;
					continue;
				}
			if (soap_flag_path1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:path", &(a->CLIPSVR__OutMessage::path), "xsd:string"))
				{	soap_flag_path1--;
					continue;
				}
			if (soap_flag_port1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "CLIPSVR:port", &(a->CLIPSVR__OutMessage::port), "xsd:int"))
				{	soap_flag_port1--;
					continue;
				}
			if (soap_flag_user1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:user", &(a->CLIPSVR__OutMessage::user), "xsd:string"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_pass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:pass", &(a->CLIPSVR__OutMessage::pass), "xsd:string"))
				{	soap_flag_pass1--;
					continue;
				}
			if (soap_flag_callbackurl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:callbackurl", &(a->CLIPSVR__OutMessage::callbackurl), "xsd:string"))
				{	soap_flag_callbackurl1--;
					continue;
				}
			if (soap_flag_emerg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:emerg", &(a->CLIPSVR__OutMessage::emerg), "xsd:string"))
				{	soap_flag_emerg1--;
					continue;
				}
			if (soap_flag_SourceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "CLIPSVR:SourceID", &(a->CLIPSVR__OutMessage::SourceID), "xsd:string"))
				{	soap_flag_SourceID1--;
					continue;
				}
			if (soap_flag_BreakPointList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToCLIPSVR__ArrayOfBreakPoint(soap, "CLIPSVR:BreakPointList", &(a->CLIPSVR__OutMessage::BreakPointList), "CLIPSVR:ArrayOfBreakPoint"))
				{	soap_flag_BreakPointList1--;
					continue;
				}
			if (soap_flag_ExtendAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, "CLIPSVR:ExtendAttributes", &(a->CLIPSVR__OutMessage::ExtendAttributes), "CLIPSVR:ArrayOfExtentionAttributeTypeExtentionAttribute"))
				{	soap_flag_ExtendAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (CLIPSVR__OutMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CLIPSVR__OutMessage, 0, sizeof(CLIPSVR__OutMessage), 0, soap_copy_CLIPSVR__OutMessage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_playDate1 > 0 || soap_flag_HD1 > 0 || soap_flag_startpoint1 > 0 || soap_flag_endpoint1 > 0 || soap_flag_length1 > 0 || soap_flag_port1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 CLIPSVR__OutMessage * SOAP_FMAC4 soap_instantiate_CLIPSVR__OutMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_CLIPSVR__OutMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_CLIPSVR__OutMessage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new CLIPSVR__OutMessage;
		if (size)
			*size = sizeof(CLIPSVR__OutMessage);
		((CLIPSVR__OutMessage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new CLIPSVR__OutMessage[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(CLIPSVR__OutMessage);
		for (int i = 0; i < n; i++)
			((CLIPSVR__OutMessage*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (CLIPSVR__OutMessage*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_CLIPSVR__OutMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying CLIPSVR__OutMessage %p -> %p\n", q, p));
	*(CLIPSVR__OutMessage*)p = *(CLIPSVR__OutMessage*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___CLIPSVR3__QueryCache(struct soap *soap, struct __CLIPSVR3__QueryCache *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CLIPSVR__QueryCache = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___CLIPSVR3__QueryCache(struct soap *soap, const struct __CLIPSVR3__QueryCache *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_CLIPSVR__QueryCache(soap, &a->CLIPSVR__QueryCache);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___CLIPSVR3__QueryCache(struct soap *soap, const struct __CLIPSVR3__QueryCache *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___CLIPSVR3__QueryCache(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___CLIPSVR3__QueryCache(struct soap *soap, const char *tag, int id, const struct __CLIPSVR3__QueryCache *a, const char *type)
{
	if (soap_out_PointerTo_CLIPSVR__QueryCache(soap, "CLIPSVR:QueryCache", -1, &a->CLIPSVR__QueryCache, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __CLIPSVR3__QueryCache * SOAP_FMAC4 soap_get___CLIPSVR3__QueryCache(struct soap *soap, struct __CLIPSVR3__QueryCache *p, const char *tag, const char *type)
{
	if ((p = soap_in___CLIPSVR3__QueryCache(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __CLIPSVR3__QueryCache * SOAP_FMAC4 soap_in___CLIPSVR3__QueryCache(struct soap *soap, const char *tag, struct __CLIPSVR3__QueryCache *a, const char *type)
{
	size_t soap_flag_CLIPSVR__QueryCache = 1;
	short soap_flag;
	a = (struct __CLIPSVR3__QueryCache *)soap_id_enter(soap, "", a, SOAP_TYPE___CLIPSVR3__QueryCache, sizeof(struct __CLIPSVR3__QueryCache), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___CLIPSVR3__QueryCache(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CLIPSVR__QueryCache && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_CLIPSVR__QueryCache(soap, "CLIPSVR:QueryCache", &a->CLIPSVR__QueryCache, ""))
				{	soap_flag_CLIPSVR__QueryCache--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __CLIPSVR3__QueryCache * SOAP_FMAC4 soap_instantiate___CLIPSVR3__QueryCache(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___CLIPSVR3__QueryCache(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___CLIPSVR3__QueryCache, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __CLIPSVR3__QueryCache;
		if (size)
			*size = sizeof(struct __CLIPSVR3__QueryCache);
	}
	else
	{	cp->ptr = (void*)new struct __CLIPSVR3__QueryCache[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __CLIPSVR3__QueryCache);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __CLIPSVR3__QueryCache*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___CLIPSVR3__QueryCache(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __CLIPSVR3__QueryCache %p -> %p\n", q, p));
	*(struct __CLIPSVR3__QueryCache*)p = *(struct __CLIPSVR3__QueryCache*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___CLIPSVR3__ClipIsExistQuery(struct soap *soap, struct __CLIPSVR3__ClipIsExistQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CLIPSVR__ClipIsExistQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___CLIPSVR3__ClipIsExistQuery(struct soap *soap, const struct __CLIPSVR3__ClipIsExistQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_CLIPSVR__ClipIsExistQuery(soap, &a->CLIPSVR__ClipIsExistQuery);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___CLIPSVR3__ClipIsExistQuery(struct soap *soap, const struct __CLIPSVR3__ClipIsExistQuery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___CLIPSVR3__ClipIsExistQuery(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___CLIPSVR3__ClipIsExistQuery(struct soap *soap, const char *tag, int id, const struct __CLIPSVR3__ClipIsExistQuery *a, const char *type)
{
	if (soap_out_PointerTo_CLIPSVR__ClipIsExistQuery(soap, "CLIPSVR:ClipIsExistQuery", -1, &a->CLIPSVR__ClipIsExistQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __CLIPSVR3__ClipIsExistQuery * SOAP_FMAC4 soap_get___CLIPSVR3__ClipIsExistQuery(struct soap *soap, struct __CLIPSVR3__ClipIsExistQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___CLIPSVR3__ClipIsExistQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __CLIPSVR3__ClipIsExistQuery * SOAP_FMAC4 soap_in___CLIPSVR3__ClipIsExistQuery(struct soap *soap, const char *tag, struct __CLIPSVR3__ClipIsExistQuery *a, const char *type)
{
	size_t soap_flag_CLIPSVR__ClipIsExistQuery = 1;
	short soap_flag;
	a = (struct __CLIPSVR3__ClipIsExistQuery *)soap_id_enter(soap, "", a, SOAP_TYPE___CLIPSVR3__ClipIsExistQuery, sizeof(struct __CLIPSVR3__ClipIsExistQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___CLIPSVR3__ClipIsExistQuery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CLIPSVR__ClipIsExistQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_CLIPSVR__ClipIsExistQuery(soap, "CLIPSVR:ClipIsExistQuery", &a->CLIPSVR__ClipIsExistQuery, ""))
				{	soap_flag_CLIPSVR__ClipIsExistQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __CLIPSVR3__ClipIsExistQuery * SOAP_FMAC4 soap_instantiate___CLIPSVR3__ClipIsExistQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___CLIPSVR3__ClipIsExistQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___CLIPSVR3__ClipIsExistQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __CLIPSVR3__ClipIsExistQuery;
		if (size)
			*size = sizeof(struct __CLIPSVR3__ClipIsExistQuery);
	}
	else
	{	cp->ptr = (void*)new struct __CLIPSVR3__ClipIsExistQuery[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __CLIPSVR3__ClipIsExistQuery);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __CLIPSVR3__ClipIsExistQuery*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___CLIPSVR3__ClipIsExistQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __CLIPSVR3__ClipIsExistQuery %p -> %p\n", q, p));
	*(struct __CLIPSVR3__ClipIsExistQuery*)p = *(struct __CLIPSVR3__ClipIsExistQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___CLIPSVR3__MaterialQuery(struct soap *soap, struct __CLIPSVR3__MaterialQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CLIPSVR__MaterialQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___CLIPSVR3__MaterialQuery(struct soap *soap, const struct __CLIPSVR3__MaterialQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_CLIPSVR__MaterialQuery(soap, &a->CLIPSVR__MaterialQuery);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___CLIPSVR3__MaterialQuery(struct soap *soap, const struct __CLIPSVR3__MaterialQuery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___CLIPSVR3__MaterialQuery(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___CLIPSVR3__MaterialQuery(struct soap *soap, const char *tag, int id, const struct __CLIPSVR3__MaterialQuery *a, const char *type)
{
	if (soap_out_PointerTo_CLIPSVR__MaterialQuery(soap, "CLIPSVR:MaterialQuery", -1, &a->CLIPSVR__MaterialQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __CLIPSVR3__MaterialQuery * SOAP_FMAC4 soap_get___CLIPSVR3__MaterialQuery(struct soap *soap, struct __CLIPSVR3__MaterialQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___CLIPSVR3__MaterialQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __CLIPSVR3__MaterialQuery * SOAP_FMAC4 soap_in___CLIPSVR3__MaterialQuery(struct soap *soap, const char *tag, struct __CLIPSVR3__MaterialQuery *a, const char *type)
{
	size_t soap_flag_CLIPSVR__MaterialQuery = 1;
	short soap_flag;
	a = (struct __CLIPSVR3__MaterialQuery *)soap_id_enter(soap, "", a, SOAP_TYPE___CLIPSVR3__MaterialQuery, sizeof(struct __CLIPSVR3__MaterialQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___CLIPSVR3__MaterialQuery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CLIPSVR__MaterialQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_CLIPSVR__MaterialQuery(soap, "CLIPSVR:MaterialQuery", &a->CLIPSVR__MaterialQuery, ""))
				{	soap_flag_CLIPSVR__MaterialQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __CLIPSVR3__MaterialQuery * SOAP_FMAC4 soap_instantiate___CLIPSVR3__MaterialQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___CLIPSVR3__MaterialQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___CLIPSVR3__MaterialQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __CLIPSVR3__MaterialQuery;
		if (size)
			*size = sizeof(struct __CLIPSVR3__MaterialQuery);
	}
	else
	{	cp->ptr = (void*)new struct __CLIPSVR3__MaterialQuery[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __CLIPSVR3__MaterialQuery);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __CLIPSVR3__MaterialQuery*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___CLIPSVR3__MaterialQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __CLIPSVR3__MaterialQuery %p -> %p\n", q, p));
	*(struct __CLIPSVR3__MaterialQuery*)p = *(struct __CLIPSVR3__MaterialQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___CLIPSVR3__TransferTaskExcuteResultNotify(struct soap *soap, struct __CLIPSVR3__TransferTaskExcuteResultNotify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CLIPSVR__TransferTaskExcuteResultNotify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___CLIPSVR3__TransferTaskExcuteResultNotify(struct soap *soap, const struct __CLIPSVR3__TransferTaskExcuteResultNotify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(soap, &a->CLIPSVR__TransferTaskExcuteResultNotify);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___CLIPSVR3__TransferTaskExcuteResultNotify(struct soap *soap, const struct __CLIPSVR3__TransferTaskExcuteResultNotify *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___CLIPSVR3__TransferTaskExcuteResultNotify(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___CLIPSVR3__TransferTaskExcuteResultNotify(struct soap *soap, const char *tag, int id, const struct __CLIPSVR3__TransferTaskExcuteResultNotify *a, const char *type)
{
	if (soap_out_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(soap, "CLIPSVR:TransferTaskExcuteResultNotify", -1, &a->CLIPSVR__TransferTaskExcuteResultNotify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __CLIPSVR3__TransferTaskExcuteResultNotify * SOAP_FMAC4 soap_get___CLIPSVR3__TransferTaskExcuteResultNotify(struct soap *soap, struct __CLIPSVR3__TransferTaskExcuteResultNotify *p, const char *tag, const char *type)
{
	if ((p = soap_in___CLIPSVR3__TransferTaskExcuteResultNotify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __CLIPSVR3__TransferTaskExcuteResultNotify * SOAP_FMAC4 soap_in___CLIPSVR3__TransferTaskExcuteResultNotify(struct soap *soap, const char *tag, struct __CLIPSVR3__TransferTaskExcuteResultNotify *a, const char *type)
{
	size_t soap_flag_CLIPSVR__TransferTaskExcuteResultNotify = 1;
	short soap_flag;
	a = (struct __CLIPSVR3__TransferTaskExcuteResultNotify *)soap_id_enter(soap, "", a, SOAP_TYPE___CLIPSVR3__TransferTaskExcuteResultNotify, sizeof(struct __CLIPSVR3__TransferTaskExcuteResultNotify), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___CLIPSVR3__TransferTaskExcuteResultNotify(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CLIPSVR__TransferTaskExcuteResultNotify && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(soap, "CLIPSVR:TransferTaskExcuteResultNotify", &a->CLIPSVR__TransferTaskExcuteResultNotify, ""))
				{	soap_flag_CLIPSVR__TransferTaskExcuteResultNotify--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __CLIPSVR3__TransferTaskExcuteResultNotify * SOAP_FMAC4 soap_instantiate___CLIPSVR3__TransferTaskExcuteResultNotify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___CLIPSVR3__TransferTaskExcuteResultNotify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___CLIPSVR3__TransferTaskExcuteResultNotify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __CLIPSVR3__TransferTaskExcuteResultNotify;
		if (size)
			*size = sizeof(struct __CLIPSVR3__TransferTaskExcuteResultNotify);
	}
	else
	{	cp->ptr = (void*)new struct __CLIPSVR3__TransferTaskExcuteResultNotify[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __CLIPSVR3__TransferTaskExcuteResultNotify);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __CLIPSVR3__TransferTaskExcuteResultNotify*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___CLIPSVR3__TransferTaskExcuteResultNotify(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __CLIPSVR3__TransferTaskExcuteResultNotify %p -> %p\n", q, p));
	*(struct __CLIPSVR3__TransferTaskExcuteResultNotify*)p = *(struct __CLIPSVR3__TransferTaskExcuteResultNotify*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___CLIPSVR3__OutStorageFunction(struct soap *soap, struct __CLIPSVR3__OutStorageFunction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CLIPSVR__OutStorageFunction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___CLIPSVR3__OutStorageFunction(struct soap *soap, const struct __CLIPSVR3__OutStorageFunction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_CLIPSVR__OutStorageFunction(soap, &a->CLIPSVR__OutStorageFunction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___CLIPSVR3__OutStorageFunction(struct soap *soap, const struct __CLIPSVR3__OutStorageFunction *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___CLIPSVR3__OutStorageFunction(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___CLIPSVR3__OutStorageFunction(struct soap *soap, const char *tag, int id, const struct __CLIPSVR3__OutStorageFunction *a, const char *type)
{
	if (soap_out_PointerTo_CLIPSVR__OutStorageFunction(soap, "CLIPSVR:OutStorageFunction", -1, &a->CLIPSVR__OutStorageFunction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __CLIPSVR3__OutStorageFunction * SOAP_FMAC4 soap_get___CLIPSVR3__OutStorageFunction(struct soap *soap, struct __CLIPSVR3__OutStorageFunction *p, const char *tag, const char *type)
{
	if ((p = soap_in___CLIPSVR3__OutStorageFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __CLIPSVR3__OutStorageFunction * SOAP_FMAC4 soap_in___CLIPSVR3__OutStorageFunction(struct soap *soap, const char *tag, struct __CLIPSVR3__OutStorageFunction *a, const char *type)
{
	size_t soap_flag_CLIPSVR__OutStorageFunction = 1;
	short soap_flag;
	a = (struct __CLIPSVR3__OutStorageFunction *)soap_id_enter(soap, "", a, SOAP_TYPE___CLIPSVR3__OutStorageFunction, sizeof(struct __CLIPSVR3__OutStorageFunction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___CLIPSVR3__OutStorageFunction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CLIPSVR__OutStorageFunction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_CLIPSVR__OutStorageFunction(soap, "CLIPSVR:OutStorageFunction", &a->CLIPSVR__OutStorageFunction, ""))
				{	soap_flag_CLIPSVR__OutStorageFunction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __CLIPSVR3__OutStorageFunction * SOAP_FMAC4 soap_instantiate___CLIPSVR3__OutStorageFunction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___CLIPSVR3__OutStorageFunction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___CLIPSVR3__OutStorageFunction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __CLIPSVR3__OutStorageFunction;
		if (size)
			*size = sizeof(struct __CLIPSVR3__OutStorageFunction);
	}
	else
	{	cp->ptr = (void*)new struct __CLIPSVR3__OutStorageFunction[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __CLIPSVR3__OutStorageFunction);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __CLIPSVR3__OutStorageFunction*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___CLIPSVR3__OutStorageFunction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __CLIPSVR3__OutStorageFunction %p -> %p\n", q, p));
	*(struct __CLIPSVR3__OutStorageFunction*)p = *(struct __CLIPSVR3__OutStorageFunction*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___CLIPSVR2__QueryCache(struct soap *soap, struct __CLIPSVR2__QueryCache *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CLIPSVR__QueryCache = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___CLIPSVR2__QueryCache(struct soap *soap, const struct __CLIPSVR2__QueryCache *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_CLIPSVR__QueryCache(soap, &a->CLIPSVR__QueryCache);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___CLIPSVR2__QueryCache(struct soap *soap, const struct __CLIPSVR2__QueryCache *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___CLIPSVR2__QueryCache(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___CLIPSVR2__QueryCache(struct soap *soap, const char *tag, int id, const struct __CLIPSVR2__QueryCache *a, const char *type)
{
	if (soap_out_PointerTo_CLIPSVR__QueryCache(soap, "CLIPSVR:QueryCache", -1, &a->CLIPSVR__QueryCache, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __CLIPSVR2__QueryCache * SOAP_FMAC4 soap_get___CLIPSVR2__QueryCache(struct soap *soap, struct __CLIPSVR2__QueryCache *p, const char *tag, const char *type)
{
	if ((p = soap_in___CLIPSVR2__QueryCache(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __CLIPSVR2__QueryCache * SOAP_FMAC4 soap_in___CLIPSVR2__QueryCache(struct soap *soap, const char *tag, struct __CLIPSVR2__QueryCache *a, const char *type)
{
	size_t soap_flag_CLIPSVR__QueryCache = 1;
	short soap_flag;
	a = (struct __CLIPSVR2__QueryCache *)soap_id_enter(soap, "", a, SOAP_TYPE___CLIPSVR2__QueryCache, sizeof(struct __CLIPSVR2__QueryCache), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___CLIPSVR2__QueryCache(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CLIPSVR__QueryCache && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_CLIPSVR__QueryCache(soap, "CLIPSVR:QueryCache", &a->CLIPSVR__QueryCache, ""))
				{	soap_flag_CLIPSVR__QueryCache--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __CLIPSVR2__QueryCache * SOAP_FMAC4 soap_instantiate___CLIPSVR2__QueryCache(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___CLIPSVR2__QueryCache(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___CLIPSVR2__QueryCache, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __CLIPSVR2__QueryCache;
		if (size)
			*size = sizeof(struct __CLIPSVR2__QueryCache);
	}
	else
	{	cp->ptr = (void*)new struct __CLIPSVR2__QueryCache[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __CLIPSVR2__QueryCache);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __CLIPSVR2__QueryCache*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___CLIPSVR2__QueryCache(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __CLIPSVR2__QueryCache %p -> %p\n", q, p));
	*(struct __CLIPSVR2__QueryCache*)p = *(struct __CLIPSVR2__QueryCache*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___CLIPSVR2__ClipIsExistQuery(struct soap *soap, struct __CLIPSVR2__ClipIsExistQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CLIPSVR__ClipIsExistQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___CLIPSVR2__ClipIsExistQuery(struct soap *soap, const struct __CLIPSVR2__ClipIsExistQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_CLIPSVR__ClipIsExistQuery(soap, &a->CLIPSVR__ClipIsExistQuery);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___CLIPSVR2__ClipIsExistQuery(struct soap *soap, const struct __CLIPSVR2__ClipIsExistQuery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___CLIPSVR2__ClipIsExistQuery(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___CLIPSVR2__ClipIsExistQuery(struct soap *soap, const char *tag, int id, const struct __CLIPSVR2__ClipIsExistQuery *a, const char *type)
{
	if (soap_out_PointerTo_CLIPSVR__ClipIsExistQuery(soap, "CLIPSVR:ClipIsExistQuery", -1, &a->CLIPSVR__ClipIsExistQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __CLIPSVR2__ClipIsExistQuery * SOAP_FMAC4 soap_get___CLIPSVR2__ClipIsExistQuery(struct soap *soap, struct __CLIPSVR2__ClipIsExistQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___CLIPSVR2__ClipIsExistQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __CLIPSVR2__ClipIsExistQuery * SOAP_FMAC4 soap_in___CLIPSVR2__ClipIsExistQuery(struct soap *soap, const char *tag, struct __CLIPSVR2__ClipIsExistQuery *a, const char *type)
{
	size_t soap_flag_CLIPSVR__ClipIsExistQuery = 1;
	short soap_flag;
	a = (struct __CLIPSVR2__ClipIsExistQuery *)soap_id_enter(soap, "", a, SOAP_TYPE___CLIPSVR2__ClipIsExistQuery, sizeof(struct __CLIPSVR2__ClipIsExistQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___CLIPSVR2__ClipIsExistQuery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CLIPSVR__ClipIsExistQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_CLIPSVR__ClipIsExistQuery(soap, "CLIPSVR:ClipIsExistQuery", &a->CLIPSVR__ClipIsExistQuery, ""))
				{	soap_flag_CLIPSVR__ClipIsExistQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __CLIPSVR2__ClipIsExistQuery * SOAP_FMAC4 soap_instantiate___CLIPSVR2__ClipIsExistQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___CLIPSVR2__ClipIsExistQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___CLIPSVR2__ClipIsExistQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __CLIPSVR2__ClipIsExistQuery;
		if (size)
			*size = sizeof(struct __CLIPSVR2__ClipIsExistQuery);
	}
	else
	{	cp->ptr = (void*)new struct __CLIPSVR2__ClipIsExistQuery[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __CLIPSVR2__ClipIsExistQuery);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __CLIPSVR2__ClipIsExistQuery*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___CLIPSVR2__ClipIsExistQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __CLIPSVR2__ClipIsExistQuery %p -> %p\n", q, p));
	*(struct __CLIPSVR2__ClipIsExistQuery*)p = *(struct __CLIPSVR2__ClipIsExistQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___CLIPSVR2__MaterialQuery(struct soap *soap, struct __CLIPSVR2__MaterialQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CLIPSVR__MaterialQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___CLIPSVR2__MaterialQuery(struct soap *soap, const struct __CLIPSVR2__MaterialQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_CLIPSVR__MaterialQuery(soap, &a->CLIPSVR__MaterialQuery);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___CLIPSVR2__MaterialQuery(struct soap *soap, const struct __CLIPSVR2__MaterialQuery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___CLIPSVR2__MaterialQuery(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___CLIPSVR2__MaterialQuery(struct soap *soap, const char *tag, int id, const struct __CLIPSVR2__MaterialQuery *a, const char *type)
{
	if (soap_out_PointerTo_CLIPSVR__MaterialQuery(soap, "CLIPSVR:MaterialQuery", -1, &a->CLIPSVR__MaterialQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __CLIPSVR2__MaterialQuery * SOAP_FMAC4 soap_get___CLIPSVR2__MaterialQuery(struct soap *soap, struct __CLIPSVR2__MaterialQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___CLIPSVR2__MaterialQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __CLIPSVR2__MaterialQuery * SOAP_FMAC4 soap_in___CLIPSVR2__MaterialQuery(struct soap *soap, const char *tag, struct __CLIPSVR2__MaterialQuery *a, const char *type)
{
	size_t soap_flag_CLIPSVR__MaterialQuery = 1;
	short soap_flag;
	a = (struct __CLIPSVR2__MaterialQuery *)soap_id_enter(soap, "", a, SOAP_TYPE___CLIPSVR2__MaterialQuery, sizeof(struct __CLIPSVR2__MaterialQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___CLIPSVR2__MaterialQuery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CLIPSVR__MaterialQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_CLIPSVR__MaterialQuery(soap, "CLIPSVR:MaterialQuery", &a->CLIPSVR__MaterialQuery, ""))
				{	soap_flag_CLIPSVR__MaterialQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __CLIPSVR2__MaterialQuery * SOAP_FMAC4 soap_instantiate___CLIPSVR2__MaterialQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___CLIPSVR2__MaterialQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___CLIPSVR2__MaterialQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __CLIPSVR2__MaterialQuery;
		if (size)
			*size = sizeof(struct __CLIPSVR2__MaterialQuery);
	}
	else
	{	cp->ptr = (void*)new struct __CLIPSVR2__MaterialQuery[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __CLIPSVR2__MaterialQuery);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __CLIPSVR2__MaterialQuery*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___CLIPSVR2__MaterialQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __CLIPSVR2__MaterialQuery %p -> %p\n", q, p));
	*(struct __CLIPSVR2__MaterialQuery*)p = *(struct __CLIPSVR2__MaterialQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___CLIPSVR2__TransferTaskExcuteResultNotify(struct soap *soap, struct __CLIPSVR2__TransferTaskExcuteResultNotify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CLIPSVR__TransferTaskExcuteResultNotify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___CLIPSVR2__TransferTaskExcuteResultNotify(struct soap *soap, const struct __CLIPSVR2__TransferTaskExcuteResultNotify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(soap, &a->CLIPSVR__TransferTaskExcuteResultNotify);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___CLIPSVR2__TransferTaskExcuteResultNotify(struct soap *soap, const struct __CLIPSVR2__TransferTaskExcuteResultNotify *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___CLIPSVR2__TransferTaskExcuteResultNotify(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___CLIPSVR2__TransferTaskExcuteResultNotify(struct soap *soap, const char *tag, int id, const struct __CLIPSVR2__TransferTaskExcuteResultNotify *a, const char *type)
{
	if (soap_out_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(soap, "CLIPSVR:TransferTaskExcuteResultNotify", -1, &a->CLIPSVR__TransferTaskExcuteResultNotify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __CLIPSVR2__TransferTaskExcuteResultNotify * SOAP_FMAC4 soap_get___CLIPSVR2__TransferTaskExcuteResultNotify(struct soap *soap, struct __CLIPSVR2__TransferTaskExcuteResultNotify *p, const char *tag, const char *type)
{
	if ((p = soap_in___CLIPSVR2__TransferTaskExcuteResultNotify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __CLIPSVR2__TransferTaskExcuteResultNotify * SOAP_FMAC4 soap_in___CLIPSVR2__TransferTaskExcuteResultNotify(struct soap *soap, const char *tag, struct __CLIPSVR2__TransferTaskExcuteResultNotify *a, const char *type)
{
	size_t soap_flag_CLIPSVR__TransferTaskExcuteResultNotify = 1;
	short soap_flag;
	a = (struct __CLIPSVR2__TransferTaskExcuteResultNotify *)soap_id_enter(soap, "", a, SOAP_TYPE___CLIPSVR2__TransferTaskExcuteResultNotify, sizeof(struct __CLIPSVR2__TransferTaskExcuteResultNotify), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___CLIPSVR2__TransferTaskExcuteResultNotify(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CLIPSVR__TransferTaskExcuteResultNotify && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(soap, "CLIPSVR:TransferTaskExcuteResultNotify", &a->CLIPSVR__TransferTaskExcuteResultNotify, ""))
				{	soap_flag_CLIPSVR__TransferTaskExcuteResultNotify--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __CLIPSVR2__TransferTaskExcuteResultNotify * SOAP_FMAC4 soap_instantiate___CLIPSVR2__TransferTaskExcuteResultNotify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___CLIPSVR2__TransferTaskExcuteResultNotify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___CLIPSVR2__TransferTaskExcuteResultNotify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __CLIPSVR2__TransferTaskExcuteResultNotify;
		if (size)
			*size = sizeof(struct __CLIPSVR2__TransferTaskExcuteResultNotify);
	}
	else
	{	cp->ptr = (void*)new struct __CLIPSVR2__TransferTaskExcuteResultNotify[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __CLIPSVR2__TransferTaskExcuteResultNotify);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __CLIPSVR2__TransferTaskExcuteResultNotify*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___CLIPSVR2__TransferTaskExcuteResultNotify(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __CLIPSVR2__TransferTaskExcuteResultNotify %p -> %p\n", q, p));
	*(struct __CLIPSVR2__TransferTaskExcuteResultNotify*)p = *(struct __CLIPSVR2__TransferTaskExcuteResultNotify*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___CLIPSVR2__OutStorageFunction(struct soap *soap, struct __CLIPSVR2__OutStorageFunction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CLIPSVR__OutStorageFunction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___CLIPSVR2__OutStorageFunction(struct soap *soap, const struct __CLIPSVR2__OutStorageFunction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_CLIPSVR__OutStorageFunction(soap, &a->CLIPSVR__OutStorageFunction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___CLIPSVR2__OutStorageFunction(struct soap *soap, const struct __CLIPSVR2__OutStorageFunction *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___CLIPSVR2__OutStorageFunction(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___CLIPSVR2__OutStorageFunction(struct soap *soap, const char *tag, int id, const struct __CLIPSVR2__OutStorageFunction *a, const char *type)
{
	if (soap_out_PointerTo_CLIPSVR__OutStorageFunction(soap, "CLIPSVR:OutStorageFunction", -1, &a->CLIPSVR__OutStorageFunction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __CLIPSVR2__OutStorageFunction * SOAP_FMAC4 soap_get___CLIPSVR2__OutStorageFunction(struct soap *soap, struct __CLIPSVR2__OutStorageFunction *p, const char *tag, const char *type)
{
	if ((p = soap_in___CLIPSVR2__OutStorageFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __CLIPSVR2__OutStorageFunction * SOAP_FMAC4 soap_in___CLIPSVR2__OutStorageFunction(struct soap *soap, const char *tag, struct __CLIPSVR2__OutStorageFunction *a, const char *type)
{
	size_t soap_flag_CLIPSVR__OutStorageFunction = 1;
	short soap_flag;
	a = (struct __CLIPSVR2__OutStorageFunction *)soap_id_enter(soap, "", a, SOAP_TYPE___CLIPSVR2__OutStorageFunction, sizeof(struct __CLIPSVR2__OutStorageFunction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___CLIPSVR2__OutStorageFunction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CLIPSVR__OutStorageFunction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_CLIPSVR__OutStorageFunction(soap, "CLIPSVR:OutStorageFunction", &a->CLIPSVR__OutStorageFunction, ""))
				{	soap_flag_CLIPSVR__OutStorageFunction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __CLIPSVR2__OutStorageFunction * SOAP_FMAC4 soap_instantiate___CLIPSVR2__OutStorageFunction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___CLIPSVR2__OutStorageFunction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___CLIPSVR2__OutStorageFunction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __CLIPSVR2__OutStorageFunction;
		if (size)
			*size = sizeof(struct __CLIPSVR2__OutStorageFunction);
	}
	else
	{	cp->ptr = (void*)new struct __CLIPSVR2__OutStorageFunction[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __CLIPSVR2__OutStorageFunction);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __CLIPSVR2__OutStorageFunction*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___CLIPSVR2__OutStorageFunction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __CLIPSVR2__OutStorageFunction %p -> %p\n", q, p));
	*(struct __CLIPSVR2__OutStorageFunction*)p = *(struct __CLIPSVR2__OutStorageFunction*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_CLIPSVR__QueryCacheResponse(struct soap *soap, _CLIPSVR__QueryCacheResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__CLIPSVR__QueryCacheResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_CLIPSVR__QueryCacheResponse(struct soap *soap, _CLIPSVR__QueryCacheResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_CLIPSVR__QueryCacheResponse);
	if (soap_out_PointerTo_CLIPSVR__QueryCacheResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_CLIPSVR__QueryCacheResponse(struct soap *soap, const char *tag, int id, _CLIPSVR__QueryCacheResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__CLIPSVR__QueryCacheResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _CLIPSVR__QueryCacheResponse ** SOAP_FMAC4 soap_get_PointerTo_CLIPSVR__QueryCacheResponse(struct soap *soap, _CLIPSVR__QueryCacheResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_CLIPSVR__QueryCacheResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _CLIPSVR__QueryCacheResponse ** SOAP_FMAC4 soap_in_PointerTo_CLIPSVR__QueryCacheResponse(struct soap *soap, const char *tag, _CLIPSVR__QueryCacheResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_CLIPSVR__QueryCacheResponse **)soap_malloc(soap, sizeof(_CLIPSVR__QueryCacheResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_CLIPSVR__QueryCacheResponse *)soap_instantiate__CLIPSVR__QueryCacheResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_CLIPSVR__QueryCacheResponse ** p = (_CLIPSVR__QueryCacheResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__CLIPSVR__QueryCacheResponse, sizeof(_CLIPSVR__QueryCacheResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_CLIPSVR__QueryCache(struct soap *soap, _CLIPSVR__QueryCache *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__CLIPSVR__QueryCache))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_CLIPSVR__QueryCache(struct soap *soap, _CLIPSVR__QueryCache *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_CLIPSVR__QueryCache);
	if (soap_out_PointerTo_CLIPSVR__QueryCache(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_CLIPSVR__QueryCache(struct soap *soap, const char *tag, int id, _CLIPSVR__QueryCache *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__CLIPSVR__QueryCache);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _CLIPSVR__QueryCache ** SOAP_FMAC4 soap_get_PointerTo_CLIPSVR__QueryCache(struct soap *soap, _CLIPSVR__QueryCache **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_CLIPSVR__QueryCache(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _CLIPSVR__QueryCache ** SOAP_FMAC4 soap_in_PointerTo_CLIPSVR__QueryCache(struct soap *soap, const char *tag, _CLIPSVR__QueryCache **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_CLIPSVR__QueryCache **)soap_malloc(soap, sizeof(_CLIPSVR__QueryCache *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_CLIPSVR__QueryCache *)soap_instantiate__CLIPSVR__QueryCache(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_CLIPSVR__QueryCache ** p = (_CLIPSVR__QueryCache **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__CLIPSVR__QueryCache, sizeof(_CLIPSVR__QueryCache), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_CLIPSVR__ClipIsExistQueryResponse(struct soap *soap, _CLIPSVR__ClipIsExistQueryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_CLIPSVR__ClipIsExistQueryResponse(struct soap *soap, _CLIPSVR__ClipIsExistQueryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_CLIPSVR__ClipIsExistQueryResponse);
	if (soap_out_PointerTo_CLIPSVR__ClipIsExistQueryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_CLIPSVR__ClipIsExistQueryResponse(struct soap *soap, const char *tag, int id, _CLIPSVR__ClipIsExistQueryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _CLIPSVR__ClipIsExistQueryResponse ** SOAP_FMAC4 soap_get_PointerTo_CLIPSVR__ClipIsExistQueryResponse(struct soap *soap, _CLIPSVR__ClipIsExistQueryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_CLIPSVR__ClipIsExistQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _CLIPSVR__ClipIsExistQueryResponse ** SOAP_FMAC4 soap_in_PointerTo_CLIPSVR__ClipIsExistQueryResponse(struct soap *soap, const char *tag, _CLIPSVR__ClipIsExistQueryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_CLIPSVR__ClipIsExistQueryResponse **)soap_malloc(soap, sizeof(_CLIPSVR__ClipIsExistQueryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_CLIPSVR__ClipIsExistQueryResponse *)soap_instantiate__CLIPSVR__ClipIsExistQueryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_CLIPSVR__ClipIsExistQueryResponse ** p = (_CLIPSVR__ClipIsExistQueryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__CLIPSVR__ClipIsExistQueryResponse, sizeof(_CLIPSVR__ClipIsExistQueryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_CLIPSVR__ClipIsExistQuery(struct soap *soap, _CLIPSVR__ClipIsExistQuery *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__CLIPSVR__ClipIsExistQuery))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_CLIPSVR__ClipIsExistQuery(struct soap *soap, _CLIPSVR__ClipIsExistQuery *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_CLIPSVR__ClipIsExistQuery);
	if (soap_out_PointerTo_CLIPSVR__ClipIsExistQuery(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_CLIPSVR__ClipIsExistQuery(struct soap *soap, const char *tag, int id, _CLIPSVR__ClipIsExistQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__CLIPSVR__ClipIsExistQuery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _CLIPSVR__ClipIsExistQuery ** SOAP_FMAC4 soap_get_PointerTo_CLIPSVR__ClipIsExistQuery(struct soap *soap, _CLIPSVR__ClipIsExistQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_CLIPSVR__ClipIsExistQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _CLIPSVR__ClipIsExistQuery ** SOAP_FMAC4 soap_in_PointerTo_CLIPSVR__ClipIsExistQuery(struct soap *soap, const char *tag, _CLIPSVR__ClipIsExistQuery **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_CLIPSVR__ClipIsExistQuery **)soap_malloc(soap, sizeof(_CLIPSVR__ClipIsExistQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_CLIPSVR__ClipIsExistQuery *)soap_instantiate__CLIPSVR__ClipIsExistQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_CLIPSVR__ClipIsExistQuery ** p = (_CLIPSVR__ClipIsExistQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__CLIPSVR__ClipIsExistQuery, sizeof(_CLIPSVR__ClipIsExistQuery), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_CLIPSVR__MaterialQueryResponse(struct soap *soap, _CLIPSVR__MaterialQueryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__CLIPSVR__MaterialQueryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_CLIPSVR__MaterialQueryResponse(struct soap *soap, _CLIPSVR__MaterialQueryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_CLIPSVR__MaterialQueryResponse);
	if (soap_out_PointerTo_CLIPSVR__MaterialQueryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_CLIPSVR__MaterialQueryResponse(struct soap *soap, const char *tag, int id, _CLIPSVR__MaterialQueryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__CLIPSVR__MaterialQueryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _CLIPSVR__MaterialQueryResponse ** SOAP_FMAC4 soap_get_PointerTo_CLIPSVR__MaterialQueryResponse(struct soap *soap, _CLIPSVR__MaterialQueryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_CLIPSVR__MaterialQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _CLIPSVR__MaterialQueryResponse ** SOAP_FMAC4 soap_in_PointerTo_CLIPSVR__MaterialQueryResponse(struct soap *soap, const char *tag, _CLIPSVR__MaterialQueryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_CLIPSVR__MaterialQueryResponse **)soap_malloc(soap, sizeof(_CLIPSVR__MaterialQueryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_CLIPSVR__MaterialQueryResponse *)soap_instantiate__CLIPSVR__MaterialQueryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_CLIPSVR__MaterialQueryResponse ** p = (_CLIPSVR__MaterialQueryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__CLIPSVR__MaterialQueryResponse, sizeof(_CLIPSVR__MaterialQueryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_CLIPSVR__MaterialQuery(struct soap *soap, _CLIPSVR__MaterialQuery *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__CLIPSVR__MaterialQuery))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_CLIPSVR__MaterialQuery(struct soap *soap, _CLIPSVR__MaterialQuery *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_CLIPSVR__MaterialQuery);
	if (soap_out_PointerTo_CLIPSVR__MaterialQuery(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_CLIPSVR__MaterialQuery(struct soap *soap, const char *tag, int id, _CLIPSVR__MaterialQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__CLIPSVR__MaterialQuery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _CLIPSVR__MaterialQuery ** SOAP_FMAC4 soap_get_PointerTo_CLIPSVR__MaterialQuery(struct soap *soap, _CLIPSVR__MaterialQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_CLIPSVR__MaterialQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _CLIPSVR__MaterialQuery ** SOAP_FMAC4 soap_in_PointerTo_CLIPSVR__MaterialQuery(struct soap *soap, const char *tag, _CLIPSVR__MaterialQuery **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_CLIPSVR__MaterialQuery **)soap_malloc(soap, sizeof(_CLIPSVR__MaterialQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_CLIPSVR__MaterialQuery *)soap_instantiate__CLIPSVR__MaterialQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_CLIPSVR__MaterialQuery ** p = (_CLIPSVR__MaterialQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__CLIPSVR__MaterialQuery, sizeof(_CLIPSVR__MaterialQuery), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse(struct soap *soap, _CLIPSVR__TransferTaskExcuteResultNotifyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse(struct soap *soap, _CLIPSVR__TransferTaskExcuteResultNotifyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse);
	if (soap_out_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse(struct soap *soap, const char *tag, int id, _CLIPSVR__TransferTaskExcuteResultNotifyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _CLIPSVR__TransferTaskExcuteResultNotifyResponse ** SOAP_FMAC4 soap_get_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse(struct soap *soap, _CLIPSVR__TransferTaskExcuteResultNotifyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _CLIPSVR__TransferTaskExcuteResultNotifyResponse ** SOAP_FMAC4 soap_in_PointerTo_CLIPSVR__TransferTaskExcuteResultNotifyResponse(struct soap *soap, const char *tag, _CLIPSVR__TransferTaskExcuteResultNotifyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_CLIPSVR__TransferTaskExcuteResultNotifyResponse **)soap_malloc(soap, sizeof(_CLIPSVR__TransferTaskExcuteResultNotifyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_CLIPSVR__TransferTaskExcuteResultNotifyResponse *)soap_instantiate__CLIPSVR__TransferTaskExcuteResultNotifyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_CLIPSVR__TransferTaskExcuteResultNotifyResponse ** p = (_CLIPSVR__TransferTaskExcuteResultNotifyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotifyResponse, sizeof(_CLIPSVR__TransferTaskExcuteResultNotifyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(struct soap *soap, _CLIPSVR__TransferTaskExcuteResultNotify *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(struct soap *soap, _CLIPSVR__TransferTaskExcuteResultNotify *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify);
	if (soap_out_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(struct soap *soap, const char *tag, int id, _CLIPSVR__TransferTaskExcuteResultNotify *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _CLIPSVR__TransferTaskExcuteResultNotify ** SOAP_FMAC4 soap_get_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(struct soap *soap, _CLIPSVR__TransferTaskExcuteResultNotify **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _CLIPSVR__TransferTaskExcuteResultNotify ** SOAP_FMAC4 soap_in_PointerTo_CLIPSVR__TransferTaskExcuteResultNotify(struct soap *soap, const char *tag, _CLIPSVR__TransferTaskExcuteResultNotify **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_CLIPSVR__TransferTaskExcuteResultNotify **)soap_malloc(soap, sizeof(_CLIPSVR__TransferTaskExcuteResultNotify *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_CLIPSVR__TransferTaskExcuteResultNotify *)soap_instantiate__CLIPSVR__TransferTaskExcuteResultNotify(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_CLIPSVR__TransferTaskExcuteResultNotify ** p = (_CLIPSVR__TransferTaskExcuteResultNotify **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__CLIPSVR__TransferTaskExcuteResultNotify, sizeof(_CLIPSVR__TransferTaskExcuteResultNotify), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_CLIPSVR__OutStorageFunctionResponse(struct soap *soap, _CLIPSVR__OutStorageFunctionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_CLIPSVR__OutStorageFunctionResponse(struct soap *soap, _CLIPSVR__OutStorageFunctionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_CLIPSVR__OutStorageFunctionResponse);
	if (soap_out_PointerTo_CLIPSVR__OutStorageFunctionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_CLIPSVR__OutStorageFunctionResponse(struct soap *soap, const char *tag, int id, _CLIPSVR__OutStorageFunctionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _CLIPSVR__OutStorageFunctionResponse ** SOAP_FMAC4 soap_get_PointerTo_CLIPSVR__OutStorageFunctionResponse(struct soap *soap, _CLIPSVR__OutStorageFunctionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_CLIPSVR__OutStorageFunctionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _CLIPSVR__OutStorageFunctionResponse ** SOAP_FMAC4 soap_in_PointerTo_CLIPSVR__OutStorageFunctionResponse(struct soap *soap, const char *tag, _CLIPSVR__OutStorageFunctionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_CLIPSVR__OutStorageFunctionResponse **)soap_malloc(soap, sizeof(_CLIPSVR__OutStorageFunctionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_CLIPSVR__OutStorageFunctionResponse *)soap_instantiate__CLIPSVR__OutStorageFunctionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_CLIPSVR__OutStorageFunctionResponse ** p = (_CLIPSVR__OutStorageFunctionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__CLIPSVR__OutStorageFunctionResponse, sizeof(_CLIPSVR__OutStorageFunctionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_CLIPSVR__OutStorageFunction(struct soap *soap, _CLIPSVR__OutStorageFunction *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__CLIPSVR__OutStorageFunction))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_CLIPSVR__OutStorageFunction(struct soap *soap, _CLIPSVR__OutStorageFunction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_CLIPSVR__OutStorageFunction);
	if (soap_out_PointerTo_CLIPSVR__OutStorageFunction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_CLIPSVR__OutStorageFunction(struct soap *soap, const char *tag, int id, _CLIPSVR__OutStorageFunction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__CLIPSVR__OutStorageFunction);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _CLIPSVR__OutStorageFunction ** SOAP_FMAC4 soap_get_PointerTo_CLIPSVR__OutStorageFunction(struct soap *soap, _CLIPSVR__OutStorageFunction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_CLIPSVR__OutStorageFunction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _CLIPSVR__OutStorageFunction ** SOAP_FMAC4 soap_in_PointerTo_CLIPSVR__OutStorageFunction(struct soap *soap, const char *tag, _CLIPSVR__OutStorageFunction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_CLIPSVR__OutStorageFunction **)soap_malloc(soap, sizeof(_CLIPSVR__OutStorageFunction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_CLIPSVR__OutStorageFunction *)soap_instantiate__CLIPSVR__OutStorageFunction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_CLIPSVR__OutStorageFunction ** p = (_CLIPSVR__OutStorageFunction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__CLIPSVR__OutStorageFunction, sizeof(_CLIPSVR__OutStorageFunction), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult(struct soap *soap, _ns1__ClipIsExistQueryResult_ClipArrayResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult(struct soap *soap, _ns1__ClipIsExistQueryResult_ClipArrayResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult);
	if (soap_out_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult(struct soap *soap, const char *tag, int id, _ns1__ClipIsExistQueryResult_ClipArrayResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult_ClipArrayResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult(struct soap *soap, _ns1__ClipIsExistQueryResult_ClipArrayResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult_ClipArrayResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult(struct soap *soap, const char *tag, _ns1__ClipIsExistQueryResult_ClipArrayResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ClipIsExistQueryResult_ClipArrayResult **)soap_malloc(soap, sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ClipIsExistQueryResult_ClipArrayResult *)soap_instantiate__ns1__ClipIsExistQueryResult_ClipArrayResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ClipIsExistQueryResult_ClipArrayResult ** p = (_ns1__ClipIsExistQueryResult_ClipArrayResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult, sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(struct soap *soap, _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(struct soap *soap, _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem);
	if (soap_out_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(struct soap *soap, const char *tag, int id, _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem ** SOAP_FMAC4 soap_get_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(struct soap *soap, _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem ** SOAP_FMAC4 soap_in_PointerTo_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(struct soap *soap, const char *tag, _ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem **)soap_malloc(soap, sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem *)soap_instantiate__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem ** p = (_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem, sizeof(_ns1__ClipIsExistQueryResult_ClipArrayResult_ClipItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ClipExistQueryRequest_ClipArray(struct soap *soap, _ns1__ClipExistQueryRequest_ClipArray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ClipExistQueryRequest_ClipArray(struct soap *soap, _ns1__ClipExistQueryRequest_ClipArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ClipExistQueryRequest_ClipArray);
	if (soap_out_PointerTo_ns1__ClipExistQueryRequest_ClipArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ClipExistQueryRequest_ClipArray(struct soap *soap, const char *tag, int id, _ns1__ClipExistQueryRequest_ClipArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ClipExistQueryRequest_ClipArray ** SOAP_FMAC4 soap_get_PointerTo_ns1__ClipExistQueryRequest_ClipArray(struct soap *soap, _ns1__ClipExistQueryRequest_ClipArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ClipExistQueryRequest_ClipArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__ClipExistQueryRequest_ClipArray ** SOAP_FMAC4 soap_in_PointerTo_ns1__ClipExistQueryRequest_ClipArray(struct soap *soap, const char *tag, _ns1__ClipExistQueryRequest_ClipArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ClipExistQueryRequest_ClipArray **)soap_malloc(soap, sizeof(_ns1__ClipExistQueryRequest_ClipArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ClipExistQueryRequest_ClipArray *)soap_instantiate__ns1__ClipExistQueryRequest_ClipArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ClipExistQueryRequest_ClipArray ** p = (_ns1__ClipExistQueryRequest_ClipArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ClipExistQueryRequest_ClipArray, sizeof(_ns1__ClipExistQueryRequest_ClipArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(struct soap *soap, _ns1__MaterialQueryRequest_PlanAirDate *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(struct soap *soap, _ns1__MaterialQueryRequest_PlanAirDate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__MaterialQueryRequest_PlanAirDate);
	if (soap_out_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(struct soap *soap, const char *tag, int id, _ns1__MaterialQueryRequest_PlanAirDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__MaterialQueryRequest_PlanAirDate ** SOAP_FMAC4 soap_get_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(struct soap *soap, _ns1__MaterialQueryRequest_PlanAirDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__MaterialQueryRequest_PlanAirDate ** SOAP_FMAC4 soap_in_PointerTo_ns1__MaterialQueryRequest_PlanAirDate(struct soap *soap, const char *tag, _ns1__MaterialQueryRequest_PlanAirDate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__MaterialQueryRequest_PlanAirDate **)soap_malloc(soap, sizeof(_ns1__MaterialQueryRequest_PlanAirDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__MaterialQueryRequest_PlanAirDate *)soap_instantiate__ns1__MaterialQueryRequest_PlanAirDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__MaterialQueryRequest_PlanAirDate ** p = (_ns1__MaterialQueryRequest_PlanAirDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__MaterialQueryRequest_PlanAirDate, sizeof(_ns1__MaterialQueryRequest_PlanAirDate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ClipIsExistQueryResult(struct soap *soap, _ns1__ClipIsExistQueryResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ClipIsExistQueryResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ClipIsExistQueryResult(struct soap *soap, _ns1__ClipIsExistQueryResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ClipIsExistQueryResult);
	if (soap_out_PointerTo_ns1__ClipIsExistQueryResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ClipIsExistQueryResult(struct soap *soap, const char *tag, int id, _ns1__ClipIsExistQueryResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ClipIsExistQueryResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__ClipIsExistQueryResult(struct soap *soap, _ns1__ClipIsExistQueryResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ClipIsExistQueryResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__ClipIsExistQueryResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__ClipIsExistQueryResult(struct soap *soap, const char *tag, _ns1__ClipIsExistQueryResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ClipIsExistQueryResult **)soap_malloc(soap, sizeof(_ns1__ClipIsExistQueryResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ClipIsExistQueryResult *)soap_instantiate__ns1__ClipIsExistQueryResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ClipIsExistQueryResult ** p = (_ns1__ClipIsExistQueryResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ClipIsExistQueryResult, sizeof(_ns1__ClipIsExistQueryResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ClipExistQueryRequest(struct soap *soap, _ns1__ClipExistQueryRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ClipExistQueryRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ClipExistQueryRequest(struct soap *soap, _ns1__ClipExistQueryRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ClipExistQueryRequest);
	if (soap_out_PointerTo_ns1__ClipExistQueryRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ClipExistQueryRequest(struct soap *soap, const char *tag, int id, _ns1__ClipExistQueryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ClipExistQueryRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ClipExistQueryRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__ClipExistQueryRequest(struct soap *soap, _ns1__ClipExistQueryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ClipExistQueryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__ClipExistQueryRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__ClipExistQueryRequest(struct soap *soap, const char *tag, _ns1__ClipExistQueryRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ClipExistQueryRequest **)soap_malloc(soap, sizeof(_ns1__ClipExistQueryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ClipExistQueryRequest *)soap_instantiate__ns1__ClipExistQueryRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ClipExistQueryRequest ** p = (_ns1__ClipExistQueryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ClipExistQueryRequest, sizeof(_ns1__ClipExistQueryRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(struct soap *soap, CLIPSVR__ArrayOfProgramBasicEntityType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(struct soap *soap, CLIPSVR__ArrayOfProgramBasicEntityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCLIPSVR__ArrayOfProgramBasicEntityType);
	if (soap_out_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(struct soap *soap, const char *tag, int id, CLIPSVR__ArrayOfProgramBasicEntityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfProgramBasicEntityType ** SOAP_FMAC4 soap_get_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(struct soap *soap, CLIPSVR__ArrayOfProgramBasicEntityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 CLIPSVR__ArrayOfProgramBasicEntityType ** SOAP_FMAC4 soap_in_PointerToCLIPSVR__ArrayOfProgramBasicEntityType(struct soap *soap, const char *tag, CLIPSVR__ArrayOfProgramBasicEntityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (CLIPSVR__ArrayOfProgramBasicEntityType **)soap_malloc(soap, sizeof(CLIPSVR__ArrayOfProgramBasicEntityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (CLIPSVR__ArrayOfProgramBasicEntityType *)soap_instantiate_CLIPSVR__ArrayOfProgramBasicEntityType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	CLIPSVR__ArrayOfProgramBasicEntityType ** p = (CLIPSVR__ArrayOfProgramBasicEntityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_CLIPSVR__ArrayOfProgramBasicEntityType, sizeof(CLIPSVR__ArrayOfProgramBasicEntityType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MaterialQueryRequest(struct soap *soap, _ns1__MaterialQueryRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__MaterialQueryRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MaterialQueryRequest(struct soap *soap, _ns1__MaterialQueryRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__MaterialQueryRequest);
	if (soap_out_PointerTo_ns1__MaterialQueryRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MaterialQueryRequest(struct soap *soap, const char *tag, int id, _ns1__MaterialQueryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__MaterialQueryRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__MaterialQueryRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__MaterialQueryRequest(struct soap *soap, _ns1__MaterialQueryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MaterialQueryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__MaterialQueryRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__MaterialQueryRequest(struct soap *soap, const char *tag, _ns1__MaterialQueryRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__MaterialQueryRequest **)soap_malloc(soap, sizeof(_ns1__MaterialQueryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__MaterialQueryRequest *)soap_instantiate__ns1__MaterialQueryRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__MaterialQueryRequest ** p = (_ns1__MaterialQueryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__MaterialQueryRequest, sizeof(_ns1__MaterialQueryRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCLIPSVR__StatusDesc(struct soap *soap, CLIPSVR__StatusDesc *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_CLIPSVR__StatusDesc))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCLIPSVR__StatusDesc(struct soap *soap, CLIPSVR__StatusDesc *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCLIPSVR__StatusDesc);
	if (soap_out_PointerToCLIPSVR__StatusDesc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCLIPSVR__StatusDesc(struct soap *soap, const char *tag, int id, CLIPSVR__StatusDesc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_CLIPSVR__StatusDesc);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 CLIPSVR__StatusDesc ** SOAP_FMAC4 soap_get_PointerToCLIPSVR__StatusDesc(struct soap *soap, CLIPSVR__StatusDesc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCLIPSVR__StatusDesc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 CLIPSVR__StatusDesc ** SOAP_FMAC4 soap_in_PointerToCLIPSVR__StatusDesc(struct soap *soap, const char *tag, CLIPSVR__StatusDesc **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (CLIPSVR__StatusDesc **)soap_malloc(soap, sizeof(CLIPSVR__StatusDesc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (CLIPSVR__StatusDesc *)soap_instantiate_CLIPSVR__StatusDesc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	CLIPSVR__StatusDesc ** p = (CLIPSVR__StatusDesc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_CLIPSVR__StatusDesc, sizeof(CLIPSVR__StatusDesc), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCLIPSVR__OutMessage(struct soap *soap, CLIPSVR__OutMessage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_CLIPSVR__OutMessage))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCLIPSVR__OutMessage(struct soap *soap, CLIPSVR__OutMessage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCLIPSVR__OutMessage);
	if (soap_out_PointerToCLIPSVR__OutMessage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCLIPSVR__OutMessage(struct soap *soap, const char *tag, int id, CLIPSVR__OutMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_CLIPSVR__OutMessage);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 CLIPSVR__OutMessage ** SOAP_FMAC4 soap_get_PointerToCLIPSVR__OutMessage(struct soap *soap, CLIPSVR__OutMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCLIPSVR__OutMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 CLIPSVR__OutMessage ** SOAP_FMAC4 soap_in_PointerToCLIPSVR__OutMessage(struct soap *soap, const char *tag, CLIPSVR__OutMessage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (CLIPSVR__OutMessage **)soap_malloc(soap, sizeof(CLIPSVR__OutMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (CLIPSVR__OutMessage *)soap_instantiate_CLIPSVR__OutMessage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	CLIPSVR__OutMessage ** p = (CLIPSVR__OutMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_CLIPSVR__OutMessage, sizeof(CLIPSVR__OutMessage), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProgramBasicEntityType(struct soap *soap, ns1__ProgramBasicEntityType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProgramBasicEntityType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProgramBasicEntityType(struct soap *soap, ns1__ProgramBasicEntityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ProgramBasicEntityType);
	if (soap_out_PointerTons1__ProgramBasicEntityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProgramBasicEntityType(struct soap *soap, const char *tag, int id, ns1__ProgramBasicEntityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ProgramBasicEntityType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ProgramBasicEntityType ** SOAP_FMAC4 soap_get_PointerTons1__ProgramBasicEntityType(struct soap *soap, ns1__ProgramBasicEntityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProgramBasicEntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ProgramBasicEntityType ** SOAP_FMAC4 soap_in_PointerTons1__ProgramBasicEntityType(struct soap *soap, const char *tag, ns1__ProgramBasicEntityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ProgramBasicEntityType **)soap_malloc(soap, sizeof(ns1__ProgramBasicEntityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ProgramBasicEntityType *)soap_instantiate_ns1__ProgramBasicEntityType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ProgramBasicEntityType ** p = (ns1__ProgramBasicEntityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ProgramBasicEntityType, sizeof(ns1__ProgramBasicEntityType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(struct soap *soap, _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(struct soap *soap, _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute);
	if (soap_out_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(struct soap *soap, const char *tag, int id, _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute ** SOAP_FMAC4 soap_get_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(struct soap *soap, _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute ** SOAP_FMAC4 soap_in_PointerTo_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(struct soap *soap, const char *tag, _CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute **)soap_malloc(soap, sizeof(_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute *)soap_instantiate__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute ** p = (_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute, sizeof(_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute_ExtentionAttribute), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCLIPSVR__BreakPoint(struct soap *soap, CLIPSVR__BreakPoint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_CLIPSVR__BreakPoint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCLIPSVR__BreakPoint(struct soap *soap, CLIPSVR__BreakPoint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCLIPSVR__BreakPoint);
	if (soap_out_PointerToCLIPSVR__BreakPoint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCLIPSVR__BreakPoint(struct soap *soap, const char *tag, int id, CLIPSVR__BreakPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_CLIPSVR__BreakPoint);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 CLIPSVR__BreakPoint ** SOAP_FMAC4 soap_get_PointerToCLIPSVR__BreakPoint(struct soap *soap, CLIPSVR__BreakPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCLIPSVR__BreakPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 CLIPSVR__BreakPoint ** SOAP_FMAC4 soap_in_PointerToCLIPSVR__BreakPoint(struct soap *soap, const char *tag, CLIPSVR__BreakPoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (CLIPSVR__BreakPoint **)soap_malloc(soap, sizeof(CLIPSVR__BreakPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (CLIPSVR__BreakPoint *)soap_instantiate_CLIPSVR__BreakPoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	CLIPSVR__BreakPoint ** p = (CLIPSVR__BreakPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_CLIPSVR__BreakPoint, sizeof(CLIPSVR__BreakPoint), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCLIPSVR__OutMessageFile(struct soap *soap, CLIPSVR__OutMessageFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_CLIPSVR__OutMessageFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCLIPSVR__OutMessageFile(struct soap *soap, CLIPSVR__OutMessageFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCLIPSVR__OutMessageFile);
	if (soap_out_PointerToCLIPSVR__OutMessageFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCLIPSVR__OutMessageFile(struct soap *soap, const char *tag, int id, CLIPSVR__OutMessageFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_CLIPSVR__OutMessageFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 CLIPSVR__OutMessageFile ** SOAP_FMAC4 soap_get_PointerToCLIPSVR__OutMessageFile(struct soap *soap, CLIPSVR__OutMessageFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCLIPSVR__OutMessageFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 CLIPSVR__OutMessageFile ** SOAP_FMAC4 soap_in_PointerToCLIPSVR__OutMessageFile(struct soap *soap, const char *tag, CLIPSVR__OutMessageFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (CLIPSVR__OutMessageFile **)soap_malloc(soap, sizeof(CLIPSVR__OutMessageFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (CLIPSVR__OutMessageFile *)soap_instantiate_CLIPSVR__OutMessageFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	CLIPSVR__OutMessageFile ** p = (CLIPSVR__OutMessageFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_CLIPSVR__OutMessageFile, sizeof(CLIPSVR__OutMessageFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(struct soap *soap, CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(struct soap *soap, CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute);
	if (soap_out_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(struct soap *soap, const char *tag, int id, CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute ** SOAP_FMAC4 soap_get_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(struct soap *soap, CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute ** SOAP_FMAC4 soap_in_PointerToCLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(struct soap *soap, const char *tag, CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute **)soap_malloc(soap, sizeof(CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute *)soap_instantiate_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute ** p = (CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute, sizeof(CLIPSVR__ArrayOfExtentionAttributeTypeExtentionAttribute), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCLIPSVR__ArrayOfBreakPoint(struct soap *soap, CLIPSVR__ArrayOfBreakPoint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCLIPSVR__ArrayOfBreakPoint(struct soap *soap, CLIPSVR__ArrayOfBreakPoint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCLIPSVR__ArrayOfBreakPoint);
	if (soap_out_PointerToCLIPSVR__ArrayOfBreakPoint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCLIPSVR__ArrayOfBreakPoint(struct soap *soap, const char *tag, int id, CLIPSVR__ArrayOfBreakPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfBreakPoint ** SOAP_FMAC4 soap_get_PointerToCLIPSVR__ArrayOfBreakPoint(struct soap *soap, CLIPSVR__ArrayOfBreakPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCLIPSVR__ArrayOfBreakPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 CLIPSVR__ArrayOfBreakPoint ** SOAP_FMAC4 soap_in_PointerToCLIPSVR__ArrayOfBreakPoint(struct soap *soap, const char *tag, CLIPSVR__ArrayOfBreakPoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (CLIPSVR__ArrayOfBreakPoint **)soap_malloc(soap, sizeof(CLIPSVR__ArrayOfBreakPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (CLIPSVR__ArrayOfBreakPoint *)soap_instantiate_CLIPSVR__ArrayOfBreakPoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	CLIPSVR__ArrayOfBreakPoint ** p = (CLIPSVR__ArrayOfBreakPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_CLIPSVR__ArrayOfBreakPoint, sizeof(CLIPSVR__ArrayOfBreakPoint), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCLIPSVR__ArrayOfOutMessageFile(struct soap *soap, CLIPSVR__ArrayOfOutMessageFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCLIPSVR__ArrayOfOutMessageFile(struct soap *soap, CLIPSVR__ArrayOfOutMessageFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCLIPSVR__ArrayOfOutMessageFile);
	if (soap_out_PointerToCLIPSVR__ArrayOfOutMessageFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCLIPSVR__ArrayOfOutMessageFile(struct soap *soap, const char *tag, int id, CLIPSVR__ArrayOfOutMessageFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 CLIPSVR__ArrayOfOutMessageFile ** SOAP_FMAC4 soap_get_PointerToCLIPSVR__ArrayOfOutMessageFile(struct soap *soap, CLIPSVR__ArrayOfOutMessageFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCLIPSVR__ArrayOfOutMessageFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 CLIPSVR__ArrayOfOutMessageFile ** SOAP_FMAC4 soap_in_PointerToCLIPSVR__ArrayOfOutMessageFile(struct soap *soap, const char *tag, CLIPSVR__ArrayOfOutMessageFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (CLIPSVR__ArrayOfOutMessageFile **)soap_malloc(soap, sizeof(CLIPSVR__ArrayOfOutMessageFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (CLIPSVR__ArrayOfOutMessageFile *)soap_instantiate_CLIPSVR__ArrayOfOutMessageFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	CLIPSVR__ArrayOfOutMessageFile ** p = (CLIPSVR__ArrayOfOutMessageFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_CLIPSVR__ArrayOfOutMessageFile, sizeof(CLIPSVR__ArrayOfOutMessageFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(struct soap *soap, std::vector<ns1__ProgramBasicEntityType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(struct soap *soap, const std::vector<ns1__ProgramBasicEntityType * >*a)
{
	for (std::vector<ns1__ProgramBasicEntityType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ProgramBasicEntityType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(struct soap *soap, const char *tag, int id, const std::vector<ns1__ProgramBasicEntityType * >*a, const char *type)
{
	for (std::vector<ns1__ProgramBasicEntityType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ProgramBasicEntityType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ProgramBasicEntityType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(struct soap *soap, const char *tag, std::vector<ns1__ProgramBasicEntityType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(soap, -1)))
		return NULL;
	ns1__ProgramBasicEntityType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__ProgramBasicEntityType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType, sizeof(ns1__ProgramBasicEntityType), 1))
				break;
			if (!soap_in_PointerTons1__ProgramBasicEntityType(soap, tag, NULL, "ns1:ProgramBasicEntityType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__ProgramBasicEntityType(soap, tag, &n, "ns1:ProgramBasicEntityType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<ns1__ProgramBasicEntityType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__ProgramBasicEntityType * >;
		if (size)
			*size = sizeof(std::vector<ns1__ProgramBasicEntityType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__ProgramBasicEntityType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__ProgramBasicEntityType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__ProgramBasicEntityType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__ProgramBasicEntityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__ProgramBasicEntityType * > %p -> %p\n", q, p));
	*(std::vector<ns1__ProgramBasicEntityType * >*)p = *(std::vector<ns1__ProgramBasicEntityType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(struct soap *soap, std::vector<CLIPSVR__BreakPoint * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(struct soap *soap, const std::vector<CLIPSVR__BreakPoint * >*a)
{
	for (std::vector<CLIPSVR__BreakPoint * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToCLIPSVR__BreakPoint(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(struct soap *soap, const char *tag, int id, const std::vector<CLIPSVR__BreakPoint * >*a, const char *type)
{
	for (std::vector<CLIPSVR__BreakPoint * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToCLIPSVR__BreakPoint(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<CLIPSVR__BreakPoint * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(struct soap *soap, const char *tag, std::vector<CLIPSVR__BreakPoint * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(soap, -1)))
		return NULL;
	CLIPSVR__BreakPoint *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_CLIPSVR__BreakPoint, SOAP_TYPE_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint, sizeof(CLIPSVR__BreakPoint), 1))
				break;
			if (!soap_in_PointerToCLIPSVR__BreakPoint(soap, tag, NULL, "CLIPSVR:BreakPoint"))
				break;
		}
		else
		{
			if (!soap_in_PointerToCLIPSVR__BreakPoint(soap, tag, &n, "CLIPSVR:BreakPoint"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<CLIPSVR__BreakPoint * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<CLIPSVR__BreakPoint * >;
		if (size)
			*size = sizeof(std::vector<CLIPSVR__BreakPoint * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<CLIPSVR__BreakPoint * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<CLIPSVR__BreakPoint * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<CLIPSVR__BreakPoint * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToCLIPSVR__BreakPoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<CLIPSVR__BreakPoint * > %p -> %p\n", q, p));
	*(std::vector<CLIPSVR__BreakPoint * >*)p = *(std::vector<CLIPSVR__BreakPoint * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(struct soap *soap, std::vector<CLIPSVR__OutMessageFile * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(struct soap *soap, const std::vector<CLIPSVR__OutMessageFile * >*a)
{
	for (std::vector<CLIPSVR__OutMessageFile * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToCLIPSVR__OutMessageFile(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(struct soap *soap, const char *tag, int id, const std::vector<CLIPSVR__OutMessageFile * >*a, const char *type)
{
	for (std::vector<CLIPSVR__OutMessageFile * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToCLIPSVR__OutMessageFile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<CLIPSVR__OutMessageFile * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(struct soap *soap, const char *tag, std::vector<CLIPSVR__OutMessageFile * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(soap, -1)))
		return NULL;
	CLIPSVR__OutMessageFile *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_CLIPSVR__OutMessageFile, SOAP_TYPE_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile, sizeof(CLIPSVR__OutMessageFile), 1))
				break;
			if (!soap_in_PointerToCLIPSVR__OutMessageFile(soap, tag, NULL, "CLIPSVR:OutMessageFile"))
				break;
		}
		else
		{
			if (!soap_in_PointerToCLIPSVR__OutMessageFile(soap, tag, &n, "CLIPSVR:OutMessageFile"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<CLIPSVR__OutMessageFile * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<CLIPSVR__OutMessageFile * >;
		if (size)
			*size = sizeof(std::vector<CLIPSVR__OutMessageFile * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<CLIPSVR__OutMessageFile * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<CLIPSVR__OutMessageFile * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<CLIPSVR__OutMessageFile * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToCLIPSVR__OutMessageFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<CLIPSVR__OutMessageFile * > %p -> %p\n", q, p));
	*(std::vector<CLIPSVR__OutMessageFile * >*)p = *(std::vector<CLIPSVR__OutMessageFile * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
